/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ai/types.ts
var AI_PROVIDERS, DEFAULT_AI_SETTINGS, DEFAULT_CLIPPING_SETTINGS;
var init_types = __esm({
  "src/ai/types.ts"() {
    AI_PROVIDERS = {
      gemini: {
        id: "gemini",
        name: "Google Gemini",
        displayName: "Gemini",
        defaultModel: "gemini-2.5-flash",
        endpoint: "https://generativelanguage.googleapis.com/v1beta",
        apiKeyPrefix: "AIza"
      },
      grok: {
        id: "grok",
        name: "xAI Grok",
        displayName: "Grok",
        defaultModel: "grok-4-1-fast",
        endpoint: "https://api.x.ai/v1"
      },
      claude: {
        id: "claude",
        name: "Anthropic Claude",
        displayName: "Claude",
        defaultModel: "claude-sonnet-4-5-20241022",
        endpoint: "https://api.anthropic.com/v1"
      },
      openai: {
        id: "openai",
        name: "OpenAI",
        displayName: "OpenAI",
        defaultModel: "gpt-5",
        endpoint: "https://api.openai.com/v1",
        apiKeyPrefix: "sk-"
      },
      glm: {
        id: "glm",
        name: "Zhipu AI (GLM)",
        displayName: "GLM",
        defaultModel: "glm-4.6",
        endpoint: "https://open.bigmodel.cn/api/paas/v4"
      }
    };
    DEFAULT_AI_SETTINGS = {
      provider: "gemini",
      apiKeys: {},
      models: {
        gemini: "gemini-2.5-flash",
        grok: "grok-4-1-fast",
        claude: "claude-sonnet-4-5-20241022",
        openai: "gpt-5",
        glm: "glm-4.6"
      },
      useCustomModel: false,
      customModel: "",
      defaultLanguage: "\uD55C\uAD6D\uC5B4",
      defaultTemplate: "basic-summary",
      autoTags: true,
      aiNotesFolder: "AI-Notes",
      autoOpenNote: true
    };
    DEFAULT_CLIPPING_SETTINGS = {
      defaultFolder: "Clippings",
      filenameFormat: "{title} - {date}",
      includeUrl: true,
      includeDate: true,
      includeAuthor: true,
      includeHtml: false
    };
  }
});

// src/clipping/ContentExtractor.ts
var CONTENT_EXTRACTION_SCRIPT, SELECTION_EXTRACTION_SCRIPT, GET_URL_SCRIPT, ContentExtractor;
var init_ContentExtractor = __esm({
  "src/clipping/ContentExtractor.ts"() {
    CONTENT_EXTRACTION_SCRIPT = `
(function() {
    // \uC81C\uAC70\uD560 \uC694\uC18C\uB4E4\uC758 \uC120\uD0DD\uC790
    const REMOVE_SELECTORS = [
        'script', 'style', 'noscript', 'iframe', 'svg',
        'header', 'footer', 'nav', 'aside',
        '.ad', '.ads', '.advertisement', '.sponsored',
        '.sidebar', '.navigation', '.menu', '.nav',
        '.comment', '.comments', '#comments',
        '.social', '.share', '.sharing',
        '[role="banner"]', '[role="navigation"]', '[role="complementary"]'
    ];

    // \uBA54\uC778 \uCF58\uD150\uCE20 \uC120\uD0DD\uC790 (\uC6B0\uC120\uC21C\uC704 \uC21C)
    const CONTENT_SELECTORS = [
        'article', '[role="main"]', 'main',
        '.post-content', '.article-content', '.entry-content',
        '.content', '#content', '.post', '.article'
    ];

    // \uC81C\uBAA9 \uCD94\uCD9C
    function getTitle() {
        // Open Graph \uC81C\uBAA9
        const ogTitle = document.querySelector('meta[property="og:title"]');
        if (ogTitle) return ogTitle.getAttribute('content');

        // Twitter \uC81C\uBAA9
        const twitterTitle = document.querySelector('meta[name="twitter:title"]');
        if (twitterTitle) return twitterTitle.getAttribute('content');

        // H1 \uD0DC\uADF8
        const h1 = document.querySelector('h1');
        if (h1) return h1.textContent.trim();

        // \uBB38\uC11C \uC81C\uBAA9
        return document.title || '';
    }

    // \uC0AC\uC774\uD2B8 \uC774\uB984 \uCD94\uCD9C
    function getSiteName() {
        const ogSiteName = document.querySelector('meta[property="og:site_name"]');
        if (ogSiteName) return ogSiteName.getAttribute('content');

        const hostname = window.location.hostname;
        return hostname.replace(/^www\\./, '');
    }

    // \uBA54\uC778 \uCF58\uD150\uCE20 \uC694\uC18C \uCC3E\uAE30
    function findMainContent() {
        for (const selector of CONTENT_SELECTORS) {
            const element = document.querySelector(selector);
            if (element && element.textContent.trim().length > 100) {
                return element.cloneNode(true);
            }
        }
        // \uD3F4\uBC31: body \uC0AC\uC6A9
        return document.body.cloneNode(true);
    }

    // \uBD88\uD544\uC694\uD55C \uC694\uC18C \uC81C\uAC70
    function cleanContent(element) {
        REMOVE_SELECTORS.forEach(selector => {
            element.querySelectorAll(selector).forEach(el => el.remove());
        });
        return element;
    }

    // \uD14D\uC2A4\uD2B8 \uC815\uC81C
    function cleanText(text) {
        return text
            .replace(/\\s+/g, ' ')
            .replace(/\\n\\s*\\n/g, '\\n\\n')
            .trim();
    }

    // \uBC1C\uCDCC\uBB38 \uC0DD\uC131
    function getExcerpt(text, maxLength = 200) {
        const excerpt = text.substring(0, maxLength);
        const lastSpace = excerpt.lastIndexOf(' ');
        return lastSpace > 0 ? excerpt.substring(0, lastSpace) + '...' : excerpt + '...';
    }

    // \uBA54\uC778 \uCD94\uCD9C \uB85C\uC9C1
    const mainContent = findMainContent();
    const cleanedContent = cleanContent(mainContent);
    const textContent = cleanText(cleanedContent.textContent || '');

    return {
        title: getTitle(),
        content: cleanedContent.innerHTML,
        textContent: textContent,
        excerpt: getExcerpt(textContent),
        length: textContent.length,
        siteName: getSiteName(),
        url: window.location.href
    };
})();
`;
    SELECTION_EXTRACTION_SCRIPT = `
(function() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
        return null;
    }

    const range = selection.getRangeAt(0);
    const fragment = range.cloneContents();

    // \uC784\uC2DC \uCEE8\uD14C\uC774\uB108\uC5D0 \uBCF5\uC0AC
    const container = document.createElement('div');
    container.appendChild(fragment);

    const text = selection.toString().trim();

    return {
        text: text,
        html: container.innerHTML,
        length: text.length,
        hasSelection: text.length > 0
    };
})();
`;
    GET_URL_SCRIPT = `window.location.href`;
    ContentExtractor = class {
      static async extractPageContent(webview) {
        try {
          const result = await webview.executeJavaScript(CONTENT_EXTRACTION_SCRIPT);
          return result;
        } catch (error) {
          console.error("[ContentExtractor] Failed to extract page content:", error);
          return null;
        }
      }
      static async extractSelection(webview) {
        try {
          const result = await webview.executeJavaScript(SELECTION_EXTRACTION_SCRIPT);
          return result;
        } catch (error) {
          console.error("[ContentExtractor] Failed to extract selection:", error);
          return null;
        }
      }
      static async getCurrentUrl(webview) {
        try {
          return await webview.executeJavaScript(GET_URL_SCRIPT);
        } catch (error) {
          console.error("[ContentExtractor] Failed to get URL:", error);
          return "";
        }
      }
      static cleanText(text) {
        return text.replace(/\s+/g, " ").replace(/\n\s*\n/g, "\n\n").trim();
      }
      static htmlToText(html) {
        return html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "").replace(/<[^>]+>/g, " ").replace(/&nbsp;/g, " ").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/\s+/g, " ").trim();
      }
      static estimateTokens(text) {
        return Math.ceil(text.length / 4);
      }
    };
  }
});

// src/clipping/MetadataParser.ts
var METADATA_EXTRACTION_SCRIPT, MetadataParser;
var init_MetadataParser = __esm({
  "src/clipping/MetadataParser.ts"() {
    METADATA_EXTRACTION_SCRIPT = `
(function() {
    function getMeta(name) {
        const el = document.querySelector('meta[name="' + name + '"]') ||
                   document.querySelector('meta[property="' + name + '"]');
        return el ? el.getAttribute('content') : null;
    }

    function getOG(property) {
        const el = document.querySelector('meta[property="og:' + property + '"]');
        return el ? el.getAttribute('content') : null;
    }

    function getTwitter(property) {
        const el = document.querySelector('meta[name="twitter:' + property + '"]');
        return el ? el.getAttribute('content') : null;
    }

    // JSON-LD \uB370\uC774\uD130 \uCD94\uCD9C
    function getJsonLd() {
        const scripts = document.querySelectorAll('script[type="application/ld+json"]');
        for (const script of scripts) {
            try {
                const data = JSON.parse(script.textContent);
                if (data['@type'] === 'Article' || data['@type'] === 'NewsArticle' || data['@type'] === 'BlogPosting') {
                    return data;
                }
            } catch (e) {}
        }
        return null;
    }

    // \uC791\uC131\uC790 \uCD94\uCD9C
    function getAuthor() {
        // JSON-LD
        const jsonLd = getJsonLd();
        if (jsonLd && jsonLd.author) {
            if (typeof jsonLd.author === 'string') return jsonLd.author;
            if (jsonLd.author.name) return jsonLd.author.name;
        }

        // Meta tags
        return getMeta('author') ||
               getMeta('article:author') ||
               getOG('article:author') ||
               null;
    }

    // \uB0A0\uC9DC \uCD94\uCD9C
    function getDate() {
        // JSON-LD
        const jsonLd = getJsonLd();
        if (jsonLd) {
            if (jsonLd.datePublished) return jsonLd.datePublished;
            if (jsonLd.dateCreated) return jsonLd.dateCreated;
        }

        // Meta tags
        return getMeta('article:published_time') ||
               getMeta('date') ||
               getMeta('DC.date') ||
               getOG('article:published_time') ||
               null;
    }

    // \uD0DC\uADF8/\uD0A4\uC6CC\uB4DC \uCD94\uCD9C
    function getTags() {
        const keywords = getMeta('keywords');
        if (keywords) {
            return keywords.split(',').map(k => k.trim()).filter(k => k);
        }

        const jsonLd = getJsonLd();
        if (jsonLd && jsonLd.keywords) {
            if (Array.isArray(jsonLd.keywords)) return jsonLd.keywords;
            return jsonLd.keywords.split(',').map(k => k.trim());
        }

        return [];
    }

    return {
        title: getOG('title') || getTwitter('title') || document.title || null,
        description: getOG('description') || getTwitter('description') || getMeta('description') || null,
        author: getAuthor(),
        date: getDate(),
        siteName: getOG('site_name') || window.location.hostname.replace(/^www\\./, ''),
        image: getOG('image') || getTwitter('image') || null,
        url: getOG('url') || window.location.href,
        type: getOG('type') || 'webpage',
        tags: getTags(),
        language: document.documentElement.lang || getMeta('language') || null
    };
})();
`;
    MetadataParser = class {
      static async extractMetadata(webview) {
        try {
          const result = await webview.executeJavaScript(METADATA_EXTRACTION_SCRIPT);
          return this.normalizeMetadata(result);
        } catch (error) {
          console.error("[MetadataParser] Failed to extract metadata:", error);
          return null;
        }
      }
      static normalizeMetadata(raw) {
        var _a;
        return {
          title: this.cleanString(raw.title),
          description: this.cleanString(raw.description),
          author: this.cleanString(raw.author),
          date: this.normalizeDate(raw.date),
          siteName: this.cleanString(raw.siteName),
          image: raw.image || void 0,
          url: raw.url || void 0,
          type: raw.type || "webpage",
          tags: ((_a = raw.tags) == null ? void 0 : _a.filter((t) => t && t.trim())) || [],
          language: raw.language || void 0
        };
      }
      static cleanString(str) {
        if (!str)
          return void 0;
        return str.trim().replace(/\s+/g, " ");
      }
      static normalizeDate(dateStr) {
        if (!dateStr)
          return void 0;
        try {
          const date = new Date(dateStr);
          if (isNaN(date.getTime()))
            return dateStr;
          return date.toISOString().split("T")[0];
        } catch (e) {
          return dateStr;
        }
      }
      static getCurrentDate() {
        return new Date().toISOString().split("T")[0];
      }
      static getCurrentTimestamp() {
        return new Date().toISOString();
      }
      static extractDomain(url) {
        try {
          const urlObj = new URL(url);
          return urlObj.hostname.replace(/^www\./, "");
        } catch (e) {
          return "";
        }
      }
      static normalizeUrl(url) {
        try {
          const urlObj = new URL(url);
          const removeParams = [
            "utm_source",
            "utm_medium",
            "utm_campaign",
            "utm_content",
            "utm_term",
            "ref",
            "source",
            "fbclid",
            "gclid"
          ];
          removeParams.forEach((param) => urlObj.searchParams.delete(param));
          return urlObj.toString();
        } catch (e) {
          return url;
        }
      }
    };
  }
});

// src/clipping/NoteGenerator.ts
var import_obsidian10, NoteGenerator;
var init_NoteGenerator = __esm({
  "src/clipping/NoteGenerator.ts"() {
    import_obsidian10 = require("obsidian");
    init_MetadataParser();
    NoteGenerator = class {
      constructor(options) {
        this.vault = options.vault;
        this.settings = options.settings;
      }
      async createNote(clipData) {
        try {
          const filename = this.generateFilename(clipData);
          const content = this.generateNoteContent(clipData);
          const folderPath = (0, import_obsidian10.normalizePath)(this.settings.defaultFolder);
          await this.ensureFolder(folderPath);
          const basePath = (0, import_obsidian10.normalizePath)(`${folderPath}/${filename}.md`);
          const filePath = await this.getUniqueFilePath(basePath);
          const file = await this.vault.create(filePath, content);
          return {
            path: filePath,
            content,
            file
          };
        } catch (error) {
          console.error("[NoteGenerator] Failed to create note:", error);
          return null;
        }
      }
      async appendToNote(file, clipData) {
        try {
          const clipBlock = this.generateClipBlock(clipData);
          const currentContent = await this.vault.read(file);
          const newContent = currentContent + "\n\n" + clipBlock;
          await this.vault.modify(file, newContent);
          return true;
        } catch (error) {
          console.error("[NoteGenerator] Failed to append to note:", error);
          return false;
        }
      }
      async createMultiClipNote(clips, title) {
        try {
          const filename = this.sanitizeFilename(title);
          const content = this.generateMultiClipContent(clips, title);
          const folderPath = (0, import_obsidian10.normalizePath)(this.settings.defaultFolder);
          await this.ensureFolder(folderPath);
          const basePath = (0, import_obsidian10.normalizePath)(`${folderPath}/${filename}.md`);
          const filePath = await this.getUniqueFilePath(basePath);
          const file = await this.vault.create(filePath, content);
          return {
            path: filePath,
            content,
            file
          };
        } catch (error) {
          console.error("[NoteGenerator] Failed to create multi-clip note:", error);
          return null;
        }
      }
      generateFilename(clipData) {
        var _a;
        let filename = this.settings.filenameFormat;
        filename = filename.replace("{title}", clipData.title || "Untitled").replace("{date}", MetadataParser.getCurrentDate()).replace("{site}", ((_a = clipData.metadata) == null ? void 0 : _a.siteName) || "unknown");
        return this.sanitizeFilename(filename);
      }
      sanitizeFilename(filename) {
        return filename.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim().substring(0, 100);
      }
      generateNoteContent(clipData) {
        const parts = [];
        parts.push(this.generateFrontmatter(clipData));
        parts.push(`# ${clipData.title || "Untitled"}`);
        parts.push("");
        if (clipData.content) {
          parts.push(clipData.content);
          parts.push("");
        }
        parts.push("---");
        parts.push(this.generateFooter(clipData));
        return parts.join("\n");
      }
      generateFrontmatter(clipData) {
        var _a, _b;
        const frontmatter = ["---"];
        if (this.settings.includeUrl && clipData.url) {
          frontmatter.push(`source: ${clipData.url}`);
        }
        if (this.settings.includeDate) {
          frontmatter.push(`clipped: ${clipData.clippedAt.split("T")[0]}`);
        }
        if (this.settings.includeAuthor && ((_a = clipData.metadata) == null ? void 0 : _a.author)) {
          frontmatter.push(`author: ${clipData.metadata.author}`);
        }
        if ((_b = clipData.metadata) == null ? void 0 : _b.siteName) {
          frontmatter.push(`site: ${clipData.metadata.siteName}`);
        }
        frontmatter.push("---");
        frontmatter.push("");
        return frontmatter.join("\n");
      }
      generateFooter(clipData) {
        var _a;
        const parts = [];
        if ((_a = clipData.metadata) == null ? void 0 : _a.siteName) {
          parts.push(`*\uCD9C\uCC98: ${clipData.metadata.siteName}*`);
        }
        if (clipData.url) {
          parts.push(`*[\uC6D0\uBCF8 \uB9C1\uD06C](${clipData.url})*`);
        }
        parts.push(`*\uD074\uB9AC\uD551 \uB0A0\uC9DC: ${clipData.clippedAt.split("T")[0]}*`);
        return parts.join(" | ");
      }
      generateClipBlock(clipData) {
        var _a, _b;
        const lines = ["```gate-clip"];
        lines.push(`source: ${clipData.url}`);
        lines.push(`title: ${clipData.title || "Untitled"}`);
        lines.push(`clipped: ${clipData.clippedAt.split("T")[0]}`);
        if ((_a = clipData.metadata) == null ? void 0 : _a.author) {
          lines.push(`author: ${clipData.metadata.author}`);
        }
        if ((_b = clipData.metadata) == null ? void 0 : _b.siteName) {
          lines.push(`site: ${clipData.metadata.siteName}`);
        }
        lines.push("content: |");
        const contentLines = clipData.content.split("\n");
        contentLines.forEach((line) => {
          lines.push(`  ${line}`);
        });
        lines.push("```");
        return lines.join("\n");
      }
      generateMultiClipContent(clips, title) {
        const parts = [];
        parts.push(`# ${title}`);
        parts.push("");
        parts.push("## \uC218\uC9D1\uB41C \uD074\uB9AC\uD551");
        parts.push("");
        clips.forEach((clip) => {
          parts.push(this.generateClipBlock(clip));
          parts.push("");
        });
        parts.push("## \uBD84\uC11D \uACB0\uACFC");
        parts.push("");
        parts.push("<!-- AI \uBD84\uC11D \uACB0\uACFC\uAC00 \uC5EC\uAE30\uC5D0 \uC0DD\uC131\uB429\uB2C8\uB2E4 -->");
        parts.push("");
        parts.push("---");
        parts.push(`*\uC0DD\uC131\uC77C: ${MetadataParser.getCurrentDate()}*`);
        return parts.join("\n");
      }
      async ensureFolder(folderPath) {
        const folder = this.vault.getAbstractFileByPath(folderPath);
        if (!folder) {
          await this.vault.createFolder(folderPath);
        } else if (!(folder instanceof import_obsidian10.TFolder)) {
          throw new Error(`${folderPath} exists but is not a folder`);
        }
      }
      async getUniqueFilePath(basePath) {
        let path = basePath;
        let counter = 1;
        while (this.vault.getAbstractFileByPath(path)) {
          const ext = basePath.lastIndexOf(".");
          if (ext > 0) {
            path = `${basePath.substring(0, ext)} ${counter}${basePath.substring(ext)}`;
          } else {
            path = `${basePath} ${counter}`;
          }
          counter++;
        }
        return path;
      }
    };
  }
});

// src/clipping/ClipService.ts
function generateClipId() {
  return `clip-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
function initializeClipService(options) {
  clipServiceInstance = new ClipService(options);
  return clipServiceInstance;
}
function getClipService() {
  return clipServiceInstance;
}
function updateClipServiceSettings(settings) {
  if (clipServiceInstance) {
    clipServiceInstance.updateSettings(settings);
  }
}
var ClipService, clipServiceInstance;
var init_ClipService = __esm({
  "src/clipping/ClipService.ts"() {
    init_ContentExtractor();
    init_MetadataParser();
    init_NoteGenerator();
    init_types();
    ClipService = class {
      constructor(options) {
        this.vault = options.vault;
        this.settings = options.settings || DEFAULT_CLIPPING_SETTINGS;
        this.noteGenerator = new NoteGenerator({
          vault: this.vault,
          settings: this.settings
        });
      }
      updateSettings(settings) {
        this.settings = settings;
        this.noteGenerator = new NoteGenerator({
          vault: this.vault,
          settings: this.settings
        });
      }
      async clipPage(webview, gateId) {
        try {
          const content = await ContentExtractor.extractPageContent(webview);
          if (!content) {
            return { success: false, error: "Failed to extract content" };
          }
          const metadata = await MetadataParser.extractMetadata(webview);
          const clipData = this.createClipData(content, metadata, gateId);
          const note = await this.noteGenerator.createNote(clipData);
          if (!note) {
            return { success: false, error: "Failed to create note", clipData };
          }
          return { success: true, clipData, note };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          return { success: false, error: errorMessage };
        }
      }
      async clipSelection(webview, gateId) {
        try {
          const selection = await ContentExtractor.extractSelection(webview);
          if (!selection || !selection.hasSelection) {
            return { success: false, error: "No text selected" };
          }
          const metadata = await MetadataParser.extractMetadata(webview);
          const clipData = {
            id: generateClipId(),
            url: (metadata == null ? void 0 : metadata.url) || await ContentExtractor.getCurrentUrl(webview),
            title: (metadata == null ? void 0 : metadata.title) || "Selection",
            content: selection.text,
            html: this.settings.includeHtml ? selection.html : void 0,
            metadata: {
              author: metadata == null ? void 0 : metadata.author,
              date: metadata == null ? void 0 : metadata.date,
              siteName: metadata == null ? void 0 : metadata.siteName,
              description: metadata == null ? void 0 : metadata.description,
              image: metadata == null ? void 0 : metadata.image
            },
            clippedAt: MetadataParser.getCurrentTimestamp(),
            gateId
          };
          const note = await this.noteGenerator.createNote(clipData);
          if (!note) {
            return { success: false, error: "Failed to create note", clipData };
          }
          return { success: true, clipData, note };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          return { success: false, error: errorMessage };
        }
      }
      async clipToNote(webview, gateId, targetFile) {
        try {
          const content = await ContentExtractor.extractPageContent(webview);
          if (!content) {
            return { success: false, error: "Failed to extract content" };
          }
          const metadata = await MetadataParser.extractMetadata(webview);
          const clipData = this.createClipData(content, metadata, gateId);
          const appended = await this.noteGenerator.appendToNote(targetFile, clipData);
          if (!appended) {
            return { success: false, error: "Failed to append to note", clipData };
          }
          return {
            success: true,
            clipData,
            note: { path: targetFile.path, content: "", file: targetFile }
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          return { success: false, error: errorMessage };
        }
      }
      async extractOnly(webview, gateId) {
        try {
          const content = await ContentExtractor.extractPageContent(webview);
          if (!content)
            return null;
          const metadata = await MetadataParser.extractMetadata(webview);
          return this.createClipData(content, metadata, gateId);
        } catch (error) {
          console.error("[ClipService] Extract failed:", error);
          return null;
        }
      }
      async extractSelectionOnly(webview, gateId) {
        try {
          const selection = await ContentExtractor.extractSelection(webview);
          if (!selection || !selection.hasSelection)
            return null;
          const metadata = await MetadataParser.extractMetadata(webview);
          const url = await ContentExtractor.getCurrentUrl(webview);
          return {
            id: generateClipId(),
            url: (metadata == null ? void 0 : metadata.url) || url,
            title: `Selection from ${(metadata == null ? void 0 : metadata.title) || "page"}`,
            content: selection.text,
            html: this.settings.includeHtml ? selection.html : void 0,
            metadata: {
              author: metadata == null ? void 0 : metadata.author,
              date: metadata == null ? void 0 : metadata.date,
              siteName: metadata == null ? void 0 : metadata.siteName,
              description: metadata == null ? void 0 : metadata.description,
              image: metadata == null ? void 0 : metadata.image
            },
            clippedAt: MetadataParser.getCurrentTimestamp(),
            gateId
          };
        } catch (error) {
          console.error("[ClipService] Extract selection failed:", error);
          return null;
        }
      }
      createClipData(content, metadata, gateId) {
        return {
          id: generateClipId(),
          url: (metadata == null ? void 0 : metadata.url) || "",
          title: content.title || (metadata == null ? void 0 : metadata.title) || "Untitled",
          content: content.textContent,
          html: this.settings.includeHtml ? content.content : void 0,
          metadata: {
            author: metadata == null ? void 0 : metadata.author,
            date: metadata == null ? void 0 : metadata.date,
            siteName: content.siteName || (metadata == null ? void 0 : metadata.siteName),
            description: metadata == null ? void 0 : metadata.description,
            image: metadata == null ? void 0 : metadata.image
          },
          clippedAt: MetadataParser.getCurrentTimestamp(),
          gateId
        };
      }
      estimateTokens(text) {
        return ContentExtractor.estimateTokens(text);
      }
      getContentStats(content) {
        const chars = content.length;
        const words = content.split(/\s+/).filter((w) => w).length;
        const tokens = this.estimateTokens(content);
        return { chars, words, tokens };
      }
    };
    clipServiceInstance = null;
  }
});

// src/clipping/index.ts
var clipping_exports = {};
__export(clipping_exports, {
  CONTENT_EXTRACTION_SCRIPT: () => CONTENT_EXTRACTION_SCRIPT,
  ClipService: () => ClipService,
  ContentExtractor: () => ContentExtractor,
  METADATA_EXTRACTION_SCRIPT: () => METADATA_EXTRACTION_SCRIPT,
  MetadataParser: () => MetadataParser,
  NoteGenerator: () => NoteGenerator,
  SELECTION_EXTRACTION_SCRIPT: () => SELECTION_EXTRACTION_SCRIPT,
  getClipService: () => getClipService,
  initializeClipService: () => initializeClipService,
  updateClipServiceSettings: () => updateClipServiceSettings
});
var init_clipping = __esm({
  "src/clipping/index.ts"() {
    init_ContentExtractor();
    init_MetadataParser();
    init_NoteGenerator();
    init_ClipService();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => OpenGatePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian22 = require("obsidian");

// src/SetingTab.ts
var import_obsidian4 = require("obsidian");

// src/ModalEditGate.ts
var import_obsidian2 = require("obsidian");

// src/fns/createFormEditGate.ts
var import_obsidian = require("obsidian");

// src/fns/getSvgIcon.ts
var getSvgIcon = (siteUrl) => {
  const domain = new URL(siteUrl).hostname;
  return `<svg viewBox="0 0 100 100"><image href="https://icon.horse/icon/${domain}" height="100" width="100" /></svg>`;
};

// src/fns/normalizeGateOption.ts
var normalizeGateOption = (gate) => {
  var _a;
  if (gate.url === "" || gate.url === void 0) {
    throw new Error("URL is required");
  }
  if (gate.id === "" || gate.id === void 0) {
    let seedString = gate.url;
    if (gate.profileKey != void 0 && gate.profileKey !== "open-gate" && gate.profileKey !== "") {
      seedString += gate.profileKey;
    }
    gate.id = btoa(encodeURIComponent(seedString));
  }
  if (gate.profileKey === "" || gate.profileKey === void 0) {
    gate.profileKey = "open-gate";
  }
  if (gate.zoomFactor === 0 || gate.zoomFactor === void 0) {
    gate.zoomFactor = 1;
  }
  if (gate.icon === "" || gate.icon === void 0) {
    gate.icon = ((_a = gate.url) == null ? void 0 : _a.startsWith("http")) ? getSvgIcon(gate.url) : "globe";
  }
  if (gate.title === "" || gate.title === void 0) {
    gate.title = gate.url;
  }
  return gate;
};

// src/fns/createFormEditGate.ts
var createFormEditGate = (contentEl, gateOptions, onSubmit) => {
  new import_obsidian.Setting(contentEl).setName("URL").setClass("open-gate--form-field").addText((text) => text.setPlaceholder("https://example.com").setValue(gateOptions.url).onChange(async (value) => {
    gateOptions.url = value;
  }));
  new import_obsidian.Setting(contentEl).setName("Name").setClass("open-gate--form-field").addText((text) => text.setValue(gateOptions.title).onChange(async (value) => {
    gateOptions.title = value;
  }));
  new import_obsidian.Setting(contentEl).setName("Pin to menu").setClass("open-gate--form-field").setDesc("If enabled, the gate will be pinned to the left bar").addToggle((text) => text.setValue(gateOptions.hasRibbon === true).onChange(async (value) => {
    gateOptions.hasRibbon = value;
  }));
  new import_obsidian.Setting(contentEl).setName("Position").setClass("open-gate--form-field").setDesc("What banner do you want to show?").addDropdown((text) => {
    var _a;
    return text.addOption("left", "Left").addOption("right", "Right").addOption("center", "Center").setValue((_a = gateOptions.position) != null ? _a : "right").onChange(async (value) => {
      gateOptions.position = value;
    });
  });
  new import_obsidian.Setting(contentEl).setName("Advanced Options").setClass("open-gate--form-field").addToggle((text) => text.setValue(false).onChange(async (value) => {
    if (value) {
      advancedOptions.addClass("open-gate--advanced-options--show");
    } else {
      advancedOptions.removeClass("open-gate--advanced-options--show");
    }
  }));
  const advancedOptions = contentEl.createDiv({
    cls: "open-gate--advanced-options"
  });
  new import_obsidian.Setting(advancedOptions).setName("Icon").setClass("open-gate--form-field--column").setDesc("Leave it blank to enable auto-detect").addTextArea((text) => text.setValue(gateOptions.icon).onChange(async (value) => {
    gateOptions.icon = value;
  }));
  new import_obsidian.Setting(advancedOptions).setName("User Agent").setClass("open-gate--form-field--column").setDesc("Leave it blank if you are not sure").addTextArea((text) => {
    var _a;
    return text.setValue((_a = gateOptions.userAgent) != null ? _a : "").onChange(async (value) => {
      gateOptions.userAgent = value;
    });
  });
  new import_obsidian.Setting(advancedOptions).setName("Profile Key").setClass("open-gate--form-field").setDesc("It's like profiles in Chrome, gates with the same profile can share storage").addText((text) => {
    var _a;
    return text.setValue((_a = gateOptions.profileKey) != null ? _a : "").onChange(async (value) => {
      if (value === "") {
        value = "open-gate";
      }
      gateOptions.profileKey = value;
    });
  });
  new import_obsidian.Setting(advancedOptions).setName("Zoom Factor").setClass("open-gate--form-field").setDesc("Leave it blank if you are not sure").addText((text) => {
    var _a, _b;
    return text.setValue((_b = (_a = gateOptions.zoomFactor) == null ? void 0 : _a.toString()) != null ? _b : "0.0").onChange(async (value) => {
      gateOptions.zoomFactor = parseFloat(value);
    });
  });
  const cssFieldDesc = new DocumentFragment();
  const descLink = document.createElement("a");
  descLink.href = "https://github.com/nguyenvanduocit/obsidian-open-gate/discussions/categories/snippets";
  descLink.textContent = "Check out the snippet library here";
  cssFieldDesc.appendChild(descLink);
  new import_obsidian.Setting(advancedOptions).setName("CSS").setClass("open-gate--form-field--column").setDesc(cssFieldDesc).addTextArea((text) => {
    var _a;
    return text.setValue((_a = gateOptions.css) != null ? _a : "").onChange(async (value) => {
      gateOptions.css = value;
    });
  });
  new import_obsidian.Setting(advancedOptions).setName("JavaScript").setClass("open-gate--form-field--column").setDesc("Leave it blank if you are not sure").addTextArea((text) => {
    var _a;
    return text.setValue((_a = gateOptions.js) != null ? _a : "").onChange(async (value) => {
      gateOptions.js = value;
    });
  });
  new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText(gateOptions.id ? "Update the gate" : "Create new gate").setCta().onClick(async () => {
    gateOptions = normalizeGateOption(gateOptions);
    onSubmit && onSubmit(gateOptions);
  }));
};

// src/ModalEditGate.ts
var ModalEditGate = class extends import_obsidian2.Modal {
  constructor(app, gateOptions, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.gateOptions = gateOptions;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h3", { text: "Easy Gate" });
    createFormEditGate(contentEl, this.gateOptions, (result) => {
      this.onSubmit(result);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/fns/getDefaultUserAgent.ts
function getDefaultUserAgent() {
  return "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36";
}

// src/fns/createEmptyGateOption.ts
var createEmptyGateOption = () => {
  return {
    id: "",
    title: "",
    icon: "",
    hasRibbon: true,
    position: "right",
    profileKey: "open-gate",
    url: "",
    zoomFactor: 1,
    userAgent: getDefaultUserAgent()
  };
};

// src/SetingTab.ts
init_types();

// src/ai/index.ts
init_types();

// src/ai/AIService.ts
init_types();

// src/ai/providers/BaseProvider.ts
init_types();
var import_obsidian3 = require("obsidian");
var BaseProvider = class {
  get config() {
    return AI_PROVIDERS[this.id];
  }
  async makeRequest(url, options) {
    try {
      const response = await (0, import_obsidian3.requestUrl)(options);
      return response.json;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`API request failed: ${error.message}`);
      }
      throw error;
    }
  }
  handleError(error) {
    let errorMessage = "Unknown error occurred";
    if (error instanceof Error) {
      errorMessage = error.message;
    } else if (typeof error === "string") {
      errorMessage = error;
    }
    if (errorMessage.includes("401") || errorMessage.includes("Unauthorized")) {
      return {
        success: false,
        content: "",
        error: "Invalid API key. Please check your API key in settings.",
        errorCode: "UNAUTHORIZED"
      };
    }
    if (errorMessage.includes("429") || errorMessage.includes("rate limit")) {
      return {
        success: false,
        content: "",
        error: "Rate limit exceeded. Please wait a moment and try again.",
        errorCode: "RATE_LIMIT"
      };
    }
    if (errorMessage.includes("timeout") || errorMessage.includes("ETIMEDOUT")) {
      return {
        success: false,
        content: "",
        error: "Request timed out. Please try again.",
        errorCode: "TIMEOUT"
      };
    }
    return {
      success: false,
      content: "",
      error: errorMessage,
      errorCode: "UNKNOWN"
    };
  }
  estimateTokens(text) {
    const hasKorean = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/.test(text);
    const multiplier = hasKorean ? 1.5 : 1;
    return Math.ceil(text.length / 4 * multiplier);
  }
};

// src/ai/providers/GeminiProvider.ts
var GeminiProvider = class extends BaseProvider {
  constructor() {
    super(...arguments);
    this.id = "gemini";
    this.name = "Google Gemini";
  }
  async testApiKey(apiKey) {
    try {
      const model = this.config.defaultModel;
      const url = `${this.config.endpoint}/models/${model}:generateContent?key=${apiKey}`;
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: "Hello" }], role: "user" }]
        })
      });
      return !response.error && !!response.candidates;
    } catch (error) {
      console.error("Gemini API key test failed:", error);
      return false;
    }
  }
  async generateText(messages, apiKey, options) {
    var _a, _b, _c;
    const model = (options == null ? void 0 : options.model) || this.config.defaultModel;
    const url = `${this.config.endpoint}/models/${model}:generateContent?key=${apiKey}`;
    const { contents, systemInstruction } = this.convertMessages(messages);
    const requestBody = {
      contents,
      generationConfig: {
        temperature: (_a = options == null ? void 0 : options.temperature) != null ? _a : 0.7,
        maxOutputTokens: (_b = options == null ? void 0 : options.maxTokens) != null ? _b : 4096,
        topP: 0.95,
        topK: 40
      }
    };
    if (systemInstruction) {
      requestBody.systemInstruction = {
        parts: [{ text: systemInstruction }]
      };
    }
    try {
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.error) {
        return {
          success: false,
          content: "",
          error: response.error.message,
          errorCode: response.error.status
        };
      }
      if (!response.candidates || response.candidates.length === 0) {
        return {
          success: false,
          content: "",
          error: "No response generated"
        };
      }
      const generatedText = response.candidates[0].content.parts.map((part) => part.text).join("");
      return {
        success: true,
        content: generatedText,
        tokensUsed: (_c = response.usageMetadata) == null ? void 0 : _c.totalTokenCount
      };
    } catch (error) {
      return this.handleError(error);
    }
  }
  convertMessages(messages) {
    const contents = [];
    let systemInstruction = null;
    for (const msg of messages) {
      if (msg.role === "system") {
        systemInstruction = msg.content;
      } else {
        contents.push({
          parts: [{ text: msg.content }],
          role: msg.role === "assistant" ? "model" : "user"
        });
      }
    }
    return { contents, systemInstruction };
  }
};

// src/ai/providers/GrokProvider.ts
var GrokProvider = class extends BaseProvider {
  constructor() {
    super(...arguments);
    this.id = "grok";
    this.name = "xAI Grok";
  }
  async testApiKey(apiKey) {
    try {
      const url = `${this.config.endpoint}/models`;
      const response = await this.makeRequest(url, {
        url,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        }
      });
      return !!response.data && !response.error;
    } catch (error) {
      console.error("Grok API key test failed:", error);
      return false;
    }
  }
  async generateText(messages, apiKey, options) {
    var _a, _b, _c;
    const model = (options == null ? void 0 : options.model) || this.config.defaultModel;
    const url = `${this.config.endpoint}/chat/completions`;
    const requestBody = {
      model,
      messages: messages.map((msg) => ({
        role: msg.role,
        content: msg.content
      })),
      temperature: (_a = options == null ? void 0 : options.temperature) != null ? _a : 0.7,
      max_tokens: (_b = options == null ? void 0 : options.maxTokens) != null ? _b : 4096,
      stream: false
    };
    try {
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.error) {
        return {
          success: false,
          content: "",
          error: response.error.message,
          errorCode: response.error.code
        };
      }
      if (!response.choices || response.choices.length === 0) {
        return {
          success: false,
          content: "",
          error: "No response generated"
        };
      }
      const generatedText = response.choices[0].message.content;
      return {
        success: true,
        content: generatedText,
        tokensUsed: (_c = response.usage) == null ? void 0 : _c.total_tokens
      };
    } catch (error) {
      return this.handleError(error);
    }
  }
};

// src/ai/providers/ClaudeProvider.ts
var ClaudeProvider = class extends BaseProvider {
  constructor() {
    super(...arguments);
    this.id = "claude";
    this.name = "Anthropic Claude";
    this.API_VERSION = "2023-06-01";
  }
  async testApiKey(apiKey) {
    try {
      const url = `${this.config.endpoint}/messages`;
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "x-api-key": apiKey,
          "anthropic-version": this.API_VERSION,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.config.defaultModel,
          messages: [{ role: "user", content: "Hello" }],
          max_tokens: 10
        })
      });
      return !response.error && !!response.content;
    } catch (error) {
      console.error("Claude API key test failed:", error);
      return false;
    }
  }
  async generateText(messages, apiKey, options) {
    var _a, _b;
    const model = (options == null ? void 0 : options.model) || this.config.defaultModel;
    const url = `${this.config.endpoint}/messages`;
    const { claudeMessages, systemPrompt } = this.convertMessages(messages);
    const requestBody = {
      model,
      messages: claudeMessages,
      max_tokens: (_a = options == null ? void 0 : options.maxTokens) != null ? _a : 4096,
      temperature: (_b = options == null ? void 0 : options.temperature) != null ? _b : 0.7
    };
    if (systemPrompt) {
      requestBody.system = systemPrompt;
    }
    try {
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "x-api-key": apiKey,
          "anthropic-version": this.API_VERSION,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.error) {
        return {
          success: false,
          content: "",
          error: response.error.message,
          errorCode: response.error.type
        };
      }
      if (!response.content || response.content.length === 0) {
        return {
          success: false,
          content: "",
          error: "No response generated"
        };
      }
      const generatedText = response.content.filter((block) => block.type === "text").map((block) => block.text).join("");
      return {
        success: true,
        content: generatedText,
        tokensUsed: response.usage ? response.usage.input_tokens + response.usage.output_tokens : void 0
      };
    } catch (error) {
      return this.handleError(error);
    }
  }
  convertMessages(messages) {
    const claudeMessages = [];
    let systemPrompt = null;
    for (const msg of messages) {
      if (msg.role === "system") {
        systemPrompt = msg.content;
      } else {
        claudeMessages.push({
          role: msg.role,
          content: msg.content
        });
      }
    }
    return { claudeMessages, systemPrompt };
  }
};

// src/ai/providers/OpenAIProvider.ts
var OpenAIProvider = class extends BaseProvider {
  constructor() {
    super(...arguments);
    this.id = "openai";
    this.name = "OpenAI";
  }
  async testApiKey(apiKey) {
    try {
      const url = `${this.config.endpoint}/models`;
      const response = await this.makeRequest(url, {
        url,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        }
      });
      return !!response.data && !response.error;
    } catch (error) {
      console.error("OpenAI API key test failed:", error);
      return false;
    }
  }
  async generateText(messages, apiKey, options) {
    var _a, _b, _c;
    const model = (options == null ? void 0 : options.model) || this.config.defaultModel;
    const url = `${this.config.endpoint}/chat/completions`;
    const requestBody = {
      model,
      messages: messages.map((msg) => ({
        role: msg.role,
        content: msg.content
      })),
      temperature: (_a = options == null ? void 0 : options.temperature) != null ? _a : 0.7,
      max_tokens: (_b = options == null ? void 0 : options.maxTokens) != null ? _b : 4096,
      stream: false
    };
    try {
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.error) {
        return {
          success: false,
          content: "",
          error: response.error.message,
          errorCode: response.error.code
        };
      }
      if (!response.choices || response.choices.length === 0) {
        return {
          success: false,
          content: "",
          error: "No response generated"
        };
      }
      const generatedText = response.choices[0].message.content;
      return {
        success: true,
        content: generatedText,
        tokensUsed: (_c = response.usage) == null ? void 0 : _c.total_tokens
      };
    } catch (error) {
      return this.handleError(error);
    }
  }
};

// src/ai/providers/GLMProvider.ts
var GLMProvider = class extends BaseProvider {
  constructor() {
    super(...arguments);
    this.id = "glm";
    this.name = "Zhipu AI (GLM)";
  }
  generateToken(apiKey) {
    if (apiKey.includes(".")) {
      return apiKey;
    }
    const [id, secret] = apiKey.split(":");
    if (!id || !secret) {
      return apiKey;
    }
    const header = this.base64UrlEncode(JSON.stringify({
      alg: "HS256",
      sign_type: "SIGN"
    }));
    const now = Math.floor(Date.now() / 1e3);
    const payload = this.base64UrlEncode(JSON.stringify({
      api_key: id,
      exp: now + 3600,
      timestamp: now * 1e3
    }));
    const signature = this.base64UrlEncode(secret);
    return `${header}.${payload}.${signature}`;
  }
  base64UrlEncode(str) {
    const base64 = btoa(unescape(encodeURIComponent(str)));
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  async testApiKey(apiKey) {
    try {
      const url = `${this.config.endpoint}/chat/completions`;
      const token = this.generateToken(apiKey);
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: this.config.defaultModel,
          messages: [{ role: "user", content: "Hello" }],
          max_tokens: 10
        })
      });
      return !response.error && !!response.choices;
    } catch (error) {
      console.error("GLM API key test failed:", error);
      return false;
    }
  }
  async generateText(messages, apiKey, options) {
    var _a, _b, _c;
    const model = (options == null ? void 0 : options.model) || this.config.defaultModel;
    const url = `${this.config.endpoint}/chat/completions`;
    const token = this.generateToken(apiKey);
    const requestBody = {
      model,
      messages: messages.map((msg) => ({
        role: msg.role,
        content: msg.content
      })),
      temperature: (_a = options == null ? void 0 : options.temperature) != null ? _a : 0.7,
      max_tokens: (_b = options == null ? void 0 : options.maxTokens) != null ? _b : 4096,
      stream: false
    };
    try {
      const response = await this.makeRequest(url, {
        url,
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (response.error) {
        return {
          success: false,
          content: "",
          error: response.error.message,
          errorCode: response.error.code
        };
      }
      if (!response.choices || response.choices.length === 0) {
        return {
          success: false,
          content: "",
          error: "No response generated"
        };
      }
      const generatedText = response.choices[0].message.content;
      return {
        success: true,
        content: generatedText,
        tokensUsed: (_c = response.usage) == null ? void 0 : _c.total_tokens
      };
    } catch (error) {
      return this.handleError(error);
    }
  }
};

// src/ai/AIService.ts
var AIService = class {
  constructor(settings) {
    this.providers = /* @__PURE__ */ new Map();
    this.settings = settings;
    this.initializeProviders();
  }
  initializeProviders() {
    this.providers.set("gemini", new GeminiProvider());
    this.providers.set("grok", new GrokProvider());
    this.providers.set("claude", new ClaudeProvider());
    this.providers.set("openai", new OpenAIProvider());
    this.providers.set("glm", new GLMProvider());
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  getCurrentProvider() {
    return this.providers.get(this.settings.provider);
  }
  getProvider(providerId) {
    return this.providers.get(providerId);
  }
  getAllProviderConfigs() {
    return Object.values(AI_PROVIDERS);
  }
  getConfiguredProviders() {
    return Object.entries(this.settings.apiKeys).filter(([_, key]) => key && key.trim().length > 0).map(([id]) => id);
  }
  isProviderConfigured(providerId) {
    const apiKey = this.settings.apiKeys[providerId];
    return !!apiKey && apiKey.trim().length > 0;
  }
  getModelForProvider(providerId) {
    if (this.settings.useCustomModel && this.settings.provider === providerId) {
      return this.settings.customModel || this.settings.models[providerId];
    }
    return this.settings.models[providerId];
  }
  async testApiKey(providerId, apiKey) {
    const provider = this.providers.get(providerId);
    if (!provider) {
      return { success: false, error: "Provider not found" };
    }
    try {
      const isValid = await provider.testApiKey(apiKey);
      return { success: isValid, error: isValid ? void 0 : "Invalid API key" };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return { success: false, error: errorMessage };
    }
  }
  async generateText(messages, options) {
    const provider = this.getCurrentProvider();
    if (!provider) {
      return {
        success: false,
        content: "",
        error: "No provider selected"
      };
    }
    const apiKey = this.settings.apiKeys[this.settings.provider];
    if (!apiKey) {
      return {
        success: false,
        content: "",
        error: `API key not configured for ${provider.name}`
      };
    }
    const finalOptions = {
      ...options,
      model: (options == null ? void 0 : options.model) || this.getModelForProvider(this.settings.provider)
    };
    try {
      return await provider.generateText(messages, apiKey, finalOptions);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return {
        success: false,
        content: "",
        error: errorMessage
      };
    }
  }
  async generateTextWithProvider(providerId, messages, options) {
    const provider = this.providers.get(providerId);
    if (!provider) {
      return {
        success: false,
        content: "",
        error: "Provider not found"
      };
    }
    const apiKey = this.settings.apiKeys[providerId];
    if (!apiKey) {
      return {
        success: false,
        content: "",
        error: `API key not configured for ${provider.name}`
      };
    }
    const finalOptions = {
      ...options,
      model: (options == null ? void 0 : options.model) || this.getModelForProvider(providerId)
    };
    try {
      return await provider.generateText(messages, apiKey, finalOptions);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      return {
        success: false,
        content: "",
        error: errorMessage
      };
    }
  }
  async simpleGenerate(userPrompt, systemPrompt, options) {
    const messages = [];
    if (systemPrompt) {
      messages.push({ role: "system", content: systemPrompt });
    }
    messages.push({ role: "user", content: userPrompt });
    return this.generateText(messages, options);
  }
  async summarizeContent(content, language = "\uD55C\uAD6D\uC5B4", options) {
    const systemPrompt = `You are a helpful assistant that summarizes web content.
Always respond in ${language}.
Provide clear, concise summaries that capture the key points.`;
    const userPrompt = `Please summarize the following content:

${content}`;
    return this.simpleGenerate(userPrompt, systemPrompt, options);
  }
  getProviderStatus(providerId) {
    const config = AI_PROVIDERS[providerId];
    return {
      id: providerId,
      name: config.name,
      displayName: config.displayName,
      configured: this.isProviderConfigured(providerId),
      model: this.getModelForProvider(providerId),
      isDefault: this.settings.provider === providerId
    };
  }
  getAllProviderStatus() {
    return Object.keys(AI_PROVIDERS).map((id) => this.getProviderStatus(id));
  }
};
var aiServiceInstance = null;
function initializeAIService(settings) {
  aiServiceInstance = new AIService(settings);
  return aiServiceInstance;
}
function getAIService() {
  return aiServiceInstance;
}
function updateAIServiceSettings(settings) {
  if (aiServiceInstance) {
    aiServiceInstance.updateSettings(settings);
  }
}

// src/SetingTab.ts
var SettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async updateGate(gate) {
    await this.plugin.addGate(gate);
    this.display();
  }
  display() {
    this.shouldNotify = false;
    const { containerEl } = this;
    containerEl.empty();
    if (import_obsidian4.Platform.isMobileApp) {
      containerEl.createEl("div", {
        text: "On mobile, some websites may not work. It is a limitation of Obsidian Mobile. Please use Obsidian Desktop instead. Follow me on Twitter to get the latest updates: ",
        cls: "open-gate-mobile-warning"
      }).createEl("a", {
        text: "@reallygood83",
        cls: "open-gate-mobile-link",
        href: "https://twitter.com/reallygood83"
      });
    }
    containerEl.createEl("h2", { text: "\u{1F310} Gates" });
    containerEl.createEl("button", { text: "New gate", cls: "mod-cta" }).addEventListener("click", () => {
      new ModalEditGate(this.app, createEmptyGateOption(), this.updateGate.bind(this)).open();
    });
    containerEl.createEl("hr");
    const settingContainerEl = containerEl.createDiv("setting-container");
    for (const gateId in this.plugin.settings.gates) {
      const gate = this.plugin.settings.gates[gateId];
      const gateEl = settingContainerEl.createEl("div", {
        attr: {
          "data-gate-id": gate.id,
          class: "open-gate--setting--gate"
        }
      });
      new import_obsidian4.Setting(gateEl).setName(gate.title).setDesc(gate.url).addButton((button) => {
        button.setButtonText("Delete").onClick(async () => {
          await this.plugin.removeGate(gateId);
          gateEl.remove();
        });
      }).addButton((button) => {
        button.setButtonText("Edit").onClick(() => {
          new ModalEditGate(this.app, gate, this.updateGate.bind(this)).open();
        });
      });
    }
    if (!import_obsidian4.Platform.isMobileApp) {
      this.displayAISettings(containerEl);
    }
    containerEl.createEl("h2", { text: "\u2753 Help" });
    containerEl.createEl("small", {
      attr: {
        style: "display: block; margin-bottom: 5px"
      },
      text: "When you delete or edit a gate, you need to reload Obsidian to see the changes."
    });
    containerEl.createEl("small", {
      attr: {
        style: "display: block; margin-bottom: 1em;"
      },
      text: `To reload Obsidian, you can use the menu "view -> Force reload" or "Reload App" in the command palette.`
    });
    new import_obsidian4.Setting(containerEl).setName("Follow me on Twitter").setDesc("@reallygood83").addButton((button) => {
      button.setCta();
      button.setButtonText("YouTube").onClick(() => {
        window.open("https://www.youtube.com/@%EB%B0%B0%EC%9B%80%EC%9D%98%EB%8B%AC%EC%9D%B8-p5v");
      });
    }).addButton((button) => {
      button.setCta();
      button.setButtonText("Twitter").onClick(() => {
        window.open("https://twitter.com/reallygood83");
      });
    });
  }
  displayAISettings(containerEl) {
    containerEl.createEl("h2", { text: "\u{1F916} AI Settings" });
    this.displayAPIKeySection(containerEl);
    this.displayDefaultProviderSection(containerEl);
    this.displayCustomModelSection(containerEl);
    this.displayClippingSettings(containerEl);
    this.displayAIGenerationSettings(containerEl);
    this.displaySavedPromptsSection(containerEl);
  }
  displayAPIKeySection(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F511} AI API \uD0A4 \uAD00\uB9AC" });
    const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
    infoEl.style.cssText = "margin-bottom: 16px; padding: 12px; background: var(--background-secondary); border-radius: 8px;";
    infoEl.innerHTML = `
            <p style="margin: 0 0 8px 0;"><strong>\u{1F4CC} \uC0AC\uC6A9 \uBC29\uBC95:</strong></p>
            <ol style="margin: 0; padding-left: 20px;">
                <li>\uC0AC\uC6A9\uD560 AI Provider\uC758 API \uD0A4\uB97C \uC785\uB825\uD558\uC138\uC694</li>
                <li><strong>\uC800\uC7A5</strong> \uBC84\uD2BC\uC744 \uB20C\uB7EC API \uD0A4\uB97C \uC800\uC7A5\uD558\uC138\uC694</li>
                <li><strong>\uD14C\uC2A4\uD2B8</strong> \uBC84\uD2BC\uC73C\uB85C \uC5F0\uACB0\uC744 \uD655\uC778\uD558\uC138\uC694</li>
                <li>\uC544\uB798 "\uAE30\uBCF8 AI Provider"\uC5D0\uC11C \uC0AC\uC6A9\uD560 Provider\uB97C \uC120\uD0DD\uD558\uC138\uC694</li>
            </ol>
        `;
    const providerIds = Object.keys(AI_PROVIDERS);
    for (const providerId of providerIds) {
      const providerConfig = AI_PROVIDERS[providerId];
      const savedApiKey = this.plugin.settings.ai.apiKeys[providerId];
      const hasApiKey = savedApiKey && savedApiKey.trim().length > 0;
      const currentModel = this.plugin.settings.ai.models[providerId];
      const statusIcon = hasApiKey ? "\u{1F7E2}" : "\u26AA";
      const statusText = hasApiKey ? "\uC5F0\uACB0\uB428" : "\uBBF8\uC124\uC815";
      const settingEl = new import_obsidian4.Setting(containerEl).setName(`${statusIcon} ${providerConfig.displayName}`).setDesc(`\uC0C1\uD0DC: ${statusText} | \uBAA8\uB378: ${currentModel}`);
      let tempApiKey = "";
      settingEl.addText((text) => {
        text.setPlaceholder("API \uD0A4 \uC785\uB825...");
        text.inputEl.type = "password";
        text.inputEl.style.width = "200px";
        if (hasApiKey) {
          text.setPlaceholder("\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022");
        }
        text.onChange((value) => {
          tempApiKey = value.trim();
        });
      });
      settingEl.addButton((button) => {
        button.setButtonText("\uC800\uC7A5").onClick(async () => {
          if (tempApiKey.length > 0) {
            this.plugin.settings.ai.apiKeys[providerId] = tempApiKey;
            await this.plugin.saveSettings();
            new import_obsidian4.Notice(`\u2705 ${providerConfig.displayName} API \uD0A4\uAC00 \uC800\uC7A5\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
            this.display();
          } else {
            new import_obsidian4.Notice("\u26A0\uFE0F API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
          }
        });
      });
      settingEl.addButton((button) => {
        button.setButtonText("\uD14C\uC2A4\uD2B8").setDisabled(!hasApiKey).onClick(async () => {
          button.setButtonText("\uD14C\uC2A4\uD2B8 \uC911...");
          button.setDisabled(true);
          const aiService = getAIService();
          if (aiService) {
            const apiKey = this.plugin.settings.ai.apiKeys[providerId] || "";
            const result = await aiService.testApiKey(providerId, apiKey);
            if (result.success) {
              new import_obsidian4.Notice(`\u2705 ${providerConfig.displayName} \uC5F0\uACB0 \uC131\uACF5!`);
            } else {
              new import_obsidian4.Notice(`\u274C ${providerConfig.displayName} \uC5F0\uACB0 \uC2E4\uD328: ${result.error}`);
            }
          }
          button.setButtonText("\uD14C\uC2A4\uD2B8");
          button.setDisabled(!hasApiKey);
        });
      });
      settingEl.addExtraButton((button) => {
        button.setIcon("pencil").setTooltip("\uBAA8\uB378 \uBCC0\uACBD").onClick(() => {
          const newModel = prompt(`${providerConfig.displayName} \uBAA8\uB378\uBA85\uC744 \uC785\uB825\uD558\uC138\uC694:`, currentModel);
          if (newModel && newModel.trim().length > 0) {
            this.plugin.settings.ai.models[providerId] = newModel.trim();
            this.plugin.saveSettings();
            this.display();
          }
        });
      });
      if (hasApiKey) {
        settingEl.addExtraButton((button) => {
          button.setIcon("trash").setTooltip("API \uD0A4 \uC0AD\uC81C").onClick(async () => {
            if (confirm(`${providerConfig.displayName} API \uD0A4\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`)) {
              delete this.plugin.settings.ai.apiKeys[providerId];
              await this.plugin.saveSettings();
              this.display();
            }
          });
        });
      }
    }
  }
  displayDefaultProviderSection(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F3AF} \uAE30\uBCF8 AI Provider \uC120\uD0DD" });
    const configuredProviders = Object.keys(AI_PROVIDERS).filter((id) => this.plugin.settings.ai.apiKeys[id] && this.plugin.settings.ai.apiKeys[id].trim().length > 0);
    if (configuredProviders.length > 0) {
      const statusEl = containerEl.createEl("div", { cls: "setting-item-description" });
      statusEl.style.cssText = "margin-bottom: 12px; padding: 8px 12px; background: var(--background-modifier-success); border-radius: 6px; color: var(--text-success);";
      statusEl.innerHTML = `\u2705 <strong>${configuredProviders.length}\uAC1C</strong>\uC758 Provider\uAC00 \uC124\uC815\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4: ${configuredProviders.map((id) => AI_PROVIDERS[id].displayName).join(", ")}`;
    } else {
      const statusEl = containerEl.createEl("div", { cls: "setting-item-description" });
      statusEl.style.cssText = "margin-bottom: 12px; padding: 8px 12px; background: var(--background-modifier-error); border-radius: 6px; color: var(--text-error);";
      statusEl.innerHTML = "\u26A0\uFE0F \uC704\uC5D0\uC11C API \uD0A4\uB97C \uC124\uC815\uD558\uACE0 <strong>\uC800\uC7A5</strong> \uBC84\uD2BC\uC744 \uB20C\uB7EC\uC8FC\uC138\uC694.";
    }
    new import_obsidian4.Setting(containerEl).setName("\uC0AC\uC6A9\uD560 AI Provider").setDesc(configuredProviders.length > 0 ? "\uC544\uB798\uC5D0\uC11C \uAE30\uBCF8\uC73C\uB85C \uC0AC\uC6A9\uD560 Provider\uB97C \uC120\uD0DD\uD558\uC138\uC694." : "API \uD0A4\uAC00 \uC124\uC815\uB41C Provider\uB9CC \uC120\uD0DD\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.").addDropdown((dropdown) => {
      if (configuredProviders.length === 0) {
        dropdown.addOption("none", "\uBA3C\uC800 API \uD0A4\uB97C \uC124\uC815\uD574\uC8FC\uC138\uC694");
        dropdown.setDisabled(true);
      } else {
        for (const providerId of configuredProviders) {
          const config = AI_PROVIDERS[providerId];
          dropdown.addOption(providerId, `${config.displayName} (${this.plugin.settings.ai.models[providerId]})`);
        }
        if (configuredProviders.includes(this.plugin.settings.ai.provider)) {
          dropdown.setValue(this.plugin.settings.ai.provider);
        } else {
          this.plugin.settings.ai.provider = configuredProviders[0];
          dropdown.setValue(configuredProviders[0]);
          this.plugin.saveSettings();
        }
        dropdown.onChange(async (value) => {
          this.plugin.settings.ai.provider = value;
          await this.plugin.saveSettings();
          new import_obsidian4.Notice(`\u2705 ${AI_PROVIDERS[value].displayName}\uAC00 \uAE30\uBCF8 Provider\uB85C \uC124\uC815\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
        });
      }
    });
  }
  displayCustomModelSection(containerEl) {
    containerEl.createEl("h3", { text: "\u2699\uFE0F \uCEE4\uC2A4\uD140 \uBAA8\uB378 \uC124\uC815 (\uC120\uD0DD\uC0AC\uD56D)" });
    new import_obsidian4.Setting(containerEl).setName("\uCEE4\uC2A4\uD140 \uBAA8\uB378\uBA85 \uC0AC\uC6A9").setDesc("\uAE30\uBCF8 Provider\uC758 \uBAA8\uB378\uBA85\uC744 \uC9C1\uC811 \uC9C0\uC815\uD569\uB2C8\uB2E4.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ai.useCustomModel);
      toggle.onChange(async (value) => {
        this.plugin.settings.ai.useCustomModel = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.ai.useCustomModel) {
      new import_obsidian4.Setting(containerEl).setName("\uCEE4\uC2A4\uD140 \uBAA8\uB378\uBA85").setDesc(`\uD604\uC7AC Provider: ${AI_PROVIDERS[this.plugin.settings.ai.provider].displayName}`).addText((text) => {
        text.setPlaceholder("\uBAA8\uB378\uBA85 \uC785\uB825...");
        text.setValue(this.plugin.settings.ai.customModel);
        text.onChange(async (value) => {
          this.plugin.settings.ai.customModel = value;
          await this.plugin.saveSettings();
        });
      });
    }
  }
  displayClippingSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F4CB} \uD074\uB9AC\uD551 \uAE30\uBCF8 \uC124\uC815" });
    new import_obsidian4.Setting(containerEl).setName("\uAE30\uBCF8 \uC800\uC7A5 \uD3F4\uB354").setDesc("\uD074\uB9AC\uD551 \uB178\uD2B8\uAC00 \uC800\uC7A5\uB420 \uAE30\uBCF8 \uD3F4\uB354\uC785\uB2C8\uB2E4.").addText((text) => {
      text.setPlaceholder("Clippings");
      text.setValue(this.plugin.settings.clipping.defaultFolder);
      text.onChange(async (value) => {
        this.plugin.settings.clipping.defaultFolder = value || "Clippings";
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("\uD30C\uC77C\uBA85 \uD615\uC2DD").setDesc("{title}, {date}, {time} \uBCC0\uC218\uB97C \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.").addText((text) => {
      text.setPlaceholder("{title} - {date}");
      text.setValue(this.plugin.settings.clipping.filenameFormat);
      text.onChange(async (value) => {
        this.plugin.settings.clipping.filenameFormat = value || "{title} - {date}";
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("\uBA54\uD0C0\uB370\uC774\uD130 \uD3EC\uD568").setDesc("\uD074\uB9AC\uD551 \uB178\uD2B8\uC5D0 \uD3EC\uD568\uD560 \uBA54\uD0C0\uB370\uC774\uD130\uB97C \uC120\uD0DD\uD569\uB2C8\uB2E4.").addToggle((toggle) => {
      toggle.setTooltip("URL \uD3EC\uD568");
      toggle.setValue(this.plugin.settings.clipping.includeUrl);
      toggle.onChange(async (value) => {
        this.plugin.settings.clipping.includeUrl = value;
        await this.plugin.saveSettings();
      });
    }).addToggle((toggle) => {
      toggle.setTooltip("\uB0A0\uC9DC \uD3EC\uD568");
      toggle.setValue(this.plugin.settings.clipping.includeDate);
      toggle.onChange(async (value) => {
        this.plugin.settings.clipping.includeDate = value;
        await this.plugin.saveSettings();
      });
    }).addToggle((toggle) => {
      toggle.setTooltip("\uC791\uC131\uC790 \uD3EC\uD568");
      toggle.setValue(this.plugin.settings.clipping.includeAuthor);
      toggle.onChange(async (value) => {
        this.plugin.settings.clipping.includeAuthor = value;
        await this.plugin.saveSettings();
      });
    });
  }
  displayAIGenerationSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u2728 AI \uC0DD\uC131 \uC124\uC815" });
    new import_obsidian4.Setting(containerEl).setName("\uAE30\uBCF8 \uC5B8\uC5B4").setDesc("AI\uAC00 \uC751\uB2F5\uD560 \uB54C \uC0AC\uC6A9\uD560 \uAE30\uBCF8 \uC5B8\uC5B4\uC785\uB2C8\uB2E4.").addDropdown((dropdown) => {
      dropdown.addOption("\uD55C\uAD6D\uC5B4", "\uD55C\uAD6D\uC5B4");
      dropdown.addOption("English", "English");
      dropdown.addOption("\u65E5\u672C\u8A9E", "\u65E5\u672C\u8A9E");
      dropdown.addOption("\u4E2D\u6587", "\u4E2D\u6587");
      dropdown.setValue(this.plugin.settings.ai.defaultLanguage);
      dropdown.onChange(async (value) => {
        this.plugin.settings.ai.defaultLanguage = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("\uAE30\uBCF8 \uD15C\uD50C\uB9BF").setDesc("AI \uCC98\uB9AC \uC2DC \uAE30\uBCF8\uC73C\uB85C \uC0AC\uC6A9\uD560 \uD15C\uD50C\uB9BF\uC785\uB2C8\uB2E4.").addDropdown((dropdown) => {
      dropdown.addOption("basic-summary", "\u{1F4DD} \uAE30\uBCF8 \uC694\uC57D");
      dropdown.addOption("study-note", "\u{1F4DA} \uD559\uC2B5 \uB178\uD2B8");
      dropdown.addOption("analysis-report", "\u{1F4CA} \uBD84\uC11D \uB9AC\uD3EC\uD2B8");
      dropdown.addOption("idea-note", "\u{1F4A1} \uC544\uC774\uB514\uC5B4 \uB178\uD2B8");
      dropdown.setValue(this.plugin.settings.ai.defaultTemplate);
      dropdown.onChange(async (value) => {
        this.plugin.settings.ai.defaultTemplate = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("\uC790\uB3D9 \uD0DC\uADF8 \uC0DD\uC131").setDesc("AI\uAC00 \uCF58\uD150\uCE20\uB97C \uBD84\uC11D\uD558\uC5EC \uC790\uB3D9\uC73C\uB85C \uD0DC\uADF8\uB97C \uC0DD\uC131\uD569\uB2C8\uB2E4.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.ai.autoTags);
      toggle.onChange(async (value) => {
        this.plugin.settings.ai.autoTags = value;
        await this.plugin.saveSettings();
      });
    });
  }
  displaySavedPromptsSection(containerEl) {
    containerEl.createEl("h3", { text: "\u{1F4BE} \uC800\uC7A5\uB41C \uD504\uB86C\uD504\uD2B8" });
    const promptsContainer = containerEl.createDiv("saved-prompts-container");
    for (let i = 0; i < this.plugin.settings.savedPrompts.length; i++) {
      const prompt2 = this.plugin.settings.savedPrompts[i];
      new import_obsidian4.Setting(promptsContainer).setName(`[${prompt2.name}]`).setDesc(prompt2.prompt.substring(0, 50) + (prompt2.prompt.length > 50 ? "..." : "")).addButton((button) => {
        button.setIcon("pencil");
        button.setTooltip("\uD3B8\uC9D1");
        button.onClick(() => {
          this.editPrompt(i);
        });
      }).addButton((button) => {
        button.setIcon("trash");
        button.setTooltip("\uC0AD\uC81C");
        button.onClick(async () => {
          if (confirm(`"${prompt2.name}" \uD504\uB86C\uD504\uD2B8\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`)) {
            this.plugin.settings.savedPrompts.splice(i, 1);
            await this.plugin.saveSettings();
            this.display();
          }
        });
      });
    }
    new import_obsidian4.Setting(promptsContainer).addButton((button) => {
      button.setButtonText("+ \uC0C8 \uD504\uB86C\uD504\uD2B8 \uCD94\uAC00");
      button.onClick(() => {
        this.addNewPrompt();
      });
    });
  }
  editPrompt(index) {
    const prompt2 = this.plugin.settings.savedPrompts[index];
    const newName = window.prompt("\uD504\uB86C\uD504\uD2B8 \uC774\uB984:", prompt2.name);
    if (newName === null)
      return;
    const newPromptText = window.prompt("\uD504\uB86C\uD504\uD2B8 \uB0B4\uC6A9:", prompt2.prompt);
    if (newPromptText === null)
      return;
    this.plugin.settings.savedPrompts[index] = {
      ...prompt2,
      name: newName.trim() || prompt2.name,
      prompt: newPromptText.trim() || prompt2.prompt
    };
    this.plugin.saveSettings();
    this.display();
  }
  addNewPrompt() {
    const name = window.prompt("\uC0C8 \uD504\uB86C\uD504\uD2B8 \uC774\uB984:");
    if (!name || name.trim().length === 0)
      return;
    const promptText = window.prompt("\uD504\uB86C\uD504\uD2B8 \uB0B4\uC6A9:");
    if (!promptText || promptText.trim().length === 0)
      return;
    const newPrompt = {
      id: `prompt-${Date.now()}`,
      name: name.trim(),
      prompt: promptText.trim()
    };
    this.plugin.settings.savedPrompts.push(newPrompt);
    this.plugin.saveSettings();
    this.display();
  }
};

// src/GateView.ts
var import_obsidian14 = require("obsidian");

// src/fns/createWebviewTag.ts
var DEFAULT_URL = "about:blank";
var GOOGLE_URL = "https://google.com";
var OPEN_GATE_WEBVIEW_CLASS = "open-gate-webview";
var createWebviewTag = (params, onReady, parentDoc) => {
  var _a, _b;
  const webviewTag = (parentDoc || document).createElement("webview");
  webviewTag.setAttribute("partition", "persist:" + params.profileKey);
  webviewTag.setAttribute("src", (_a = params.url) != null ? _a : DEFAULT_URL);
  webviewTag.setAttribute("httpreferrer", (_b = params.url) != null ? _b : GOOGLE_URL);
  webviewTag.setAttribute("allowpopups", "true");
  webviewTag.addClass(OPEN_GATE_WEBVIEW_CLASS);
  if (params.userAgent) {
    webviewTag.setAttribute("useragent", params.userAgent);
  }
  webviewTag.addEventListener("dom-ready", async () => {
    if (params.zoomFactor) {
      webviewTag.setZoomFactor(params.zoomFactor);
    }
    if (params == null ? void 0 : params.css) {
      await webviewTag.insertCSS(params.css);
    }
    if (params == null ? void 0 : params.js) {
      await webviewTag.executeJavaScript(params.js);
    }
    onReady == null ? void 0 : onReady.call(null);
  });
  return webviewTag;
};

// src/GateView.ts
var import_obsidian15 = require("obsidian");

// src/fns/createIframe.ts
var createIframe = (params, onReady) => {
  var _a;
  const iframe = document.createElement("iframe");
  iframe.setAttribute("allowpopups", "");
  if ("credentialless" in iframe) {
    iframe.setAttribute("credentialless", "true");
  }
  iframe.setAttribute("src", (_a = params.url) != null ? _a : "about:blank");
  iframe.setAttribute("sandbox", "allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts allow-top-navigation-by-user-activation");
  iframe.setAttribute("allow", "encrypted-media; fullscreen; oversized-images; picture-in-picture; sync-xhr; geolocation");
  iframe.addClass("open-gate-iframe");
  iframe.addEventListener("load", () => {
    var _a2, _b;
    onReady == null ? void 0 : onReady.call(null);
    if (params == null ? void 0 : params.css) {
      const style = document.createElement("style");
      style.textContent = params.css;
      (_a2 = iframe.contentDocument) == null ? void 0 : _a2.head.appendChild(style);
    }
    if (params == null ? void 0 : params.js) {
      const script = document.createElement("script");
      script.textContent = params.js;
      (_b = iframe.contentDocument) == null ? void 0 : _b.head.appendChild(script);
    }
  });
  return iframe;
};

// src/GatePopupModal.ts
var import_obsidian5 = require("obsidian");
var import_obsidian6 = require("obsidian");
var GatePopupModal = class extends import_obsidian5.Modal {
  constructor(app, url, profileKey) {
    super(app);
    this.url = url;
    this.profileKey = profileKey || "default";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("gate-popup-modal");
    const header = contentEl.createDiv({ cls: "gate-popup-header" });
    header.createEl("h3", { text: "Quick View" });
    const body = contentEl.createDiv({ cls: "gate-popup-body" });
    body.style.height = "600px";
    body.style.width = "100%";
    const onReady = () => {
    };
    const options = {
      id: "popup",
      title: "Popup",
      icon: "globe",
      url: this.url,
      profileKey: this.profileKey
    };
    if (import_obsidian6.Platform.isMobileApp) {
      this.frame = createIframe(options, onReady);
    } else {
      this.frame = createWebviewTag(options, onReady, contentEl.doc);
    }
    body.appendChild(this.frame);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/ToastNotification.ts
var import_obsidian7 = require("obsidian");
var TOAST_ICONS = {
  success: "\u2705",
  error: "\u274C",
  warning: "\u26A0\uFE0F",
  info: "\u2139\uFE0F",
  loading: "\u{1F504}"
};
var TOAST_COLORS = {
  success: "#4caf50",
  error: "#f44336",
  warning: "#ff9800",
  info: "#2196f3",
  loading: "#9c27b0"
};
var ToastNotification = class {
  constructor() {
    this.notice = null;
    this.element = null;
  }
  show(message, options = {}) {
    const { type = "info", duration = 3e3, closable = true, action } = options;
    this.hide();
    this.notice = new import_obsidian7.Notice("", duration === 0 ? 0 : duration);
    this.element = this.notice.noticeEl;
    this.element.empty();
    this.element.addClass("easy-gate-toast");
    this.element.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border-left: 4px solid ${TOAST_COLORS[type]};
            background: var(--background-primary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 400px;
        `;
    const icon = this.element.createSpan({ cls: "toast-icon" });
    icon.textContent = TOAST_ICONS[type];
    icon.style.fontSize = "16px";
    const messageEl = this.element.createSpan({ cls: "toast-message" });
    messageEl.textContent = message;
    messageEl.style.cssText = `
            flex: 1;
            font-size: 14px;
            color: var(--text-normal);
        `;
    if (action) {
      const actionBtn = this.element.createEl("button", { cls: "toast-action" });
      actionBtn.textContent = action.label;
      actionBtn.style.cssText = `
                padding: 4px 8px;
                font-size: 12px;
                background: ${TOAST_COLORS[type]};
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            `;
      actionBtn.onclick = () => {
        action.callback();
        this.hide();
      };
    }
    if (closable && duration === 0) {
      const closeBtn = this.element.createSpan({ cls: "toast-close" });
      closeBtn.textContent = "\xD7";
      closeBtn.style.cssText = `
                cursor: pointer;
                font-size: 18px;
                color: var(--text-muted);
                padding: 0 4px;
            `;
      closeBtn.onclick = () => this.hide();
    }
    return this;
  }
  hide() {
    if (this.notice) {
      this.notice.hide();
      this.notice = null;
      this.element = null;
    }
  }
  update(message) {
    if (this.element) {
      const messageEl = this.element.querySelector(".toast-message");
      if (messageEl) {
        messageEl.textContent = message;
      }
    }
  }
  setType(type) {
    if (this.element) {
      this.element.style.borderLeftColor = TOAST_COLORS[type];
      const icon = this.element.querySelector(".toast-icon");
      if (icon) {
        icon.textContent = TOAST_ICONS[type];
      }
    }
  }
};
function showSuccess(message, duration = 3e3) {
  return new ToastNotification().show(message, { type: "success", duration });
}
function showError(message, duration = 5e3) {
  return new ToastNotification().show(message, { type: "error", duration });
}
function showWarning(message, duration = 4e3) {
  return new ToastNotification().show(message, { type: "warning", duration });
}
function showLoading(message) {
  return new ToastNotification().show(message, { type: "loading", duration: 0, closable: false });
}

// src/ui/ClipDropdown.ts
var import_obsidian8 = require("obsidian");
var ClipDropdown = class {
  constructor(options) {
    this.app = options.app;
    this.settings = options.settings;
    this.onClipPage = options.onClipPage;
    this.onClipSelection = options.onClipSelection;
    this.onClipToNote = options.onClipToNote;
    this.onOpenSettings = options.onOpenSettings;
  }
  show(event) {
    const menu = new import_obsidian8.Menu();
    menu.addItem((item) => item.setTitle("\u{1F4E5} \uC6F9\uD398\uC774\uC9C0 \uC800\uC7A5 \uC635\uC158").setDisabled(true));
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("\u{1F4C4} \uC804\uCCB4 \uD398\uC774\uC9C0 \uC800\uC7A5").setIcon("file-plus").onClick(() => {
      this.onClipPage();
    }));
    menu.addItem((item) => item.setTitle("\u2702\uFE0F \uC120\uD0DD \uC601\uC5ED \uC800\uC7A5").setIcon("scissors").onClick(() => {
      this.onClipSelection();
    }));
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("\u{1F4CE} \uAE30\uC874 \uB178\uD2B8\uC5D0 \uCD94\uAC00...").setIcon("file-input").onClick(() => {
      this.showNoteSelector();
    }));
    const recentNotes = this.getRecentClippingNotes();
    if (recentNotes.length > 0) {
      menu.addSeparator();
      menu.addItem((item) => item.setTitle("\uCD5C\uADFC \uD074\uB9AC\uD551").setDisabled(true));
      recentNotes.forEach((file) => {
        menu.addItem((item) => item.setTitle(`  \u2192 ${file.basename}`).setIcon("file").onClick(() => {
          this.onClipToNote(file);
        }));
      });
    }
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("\u2699\uFE0F \uD074\uB9AC\uD551 \uC124\uC815").setIcon("settings").onClick(() => {
      this.onOpenSettings();
    }));
    if (event instanceof MouseEvent) {
      menu.showAtMouseEvent(event);
    } else {
      const rect = event.getBoundingClientRect();
      menu.showAtPosition({ x: rect.left, y: rect.bottom });
    }
  }
  showNoteSelector() {
    const menu = new import_obsidian8.Menu();
    const clippingFolder = this.app.vault.getAbstractFileByPath(this.settings.defaultFolder);
    if (clippingFolder instanceof import_obsidian8.TFolder) {
      const files = this.getMarkdownFiles(clippingFolder);
      files.slice(0, 15).forEach((file) => {
        menu.addItem((item) => item.setTitle(file.basename).setIcon("file").onClick(() => {
          this.onClipToNote(file);
        }));
      });
      if (files.length > 15) {
        menu.addItem((item) => item.setTitle(`... ${files.length - 15}\uAC1C \uB354`).setDisabled(true));
      }
    } else {
      menu.addItem((item) => item.setTitle("\uD074\uB9AC\uD551 \uD3F4\uB354\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4").setDisabled(true));
    }
    menu.showAtMouseEvent(new MouseEvent("click"));
  }
  getMarkdownFiles(folder) {
    const files = [];
    folder.children.forEach((child) => {
      if (child instanceof import_obsidian8.TFile && child.extension === "md") {
        files.push(child);
      } else if (child instanceof import_obsidian8.TFolder) {
        files.push(...this.getMarkdownFiles(child));
      }
    });
    return files.sort((a, b) => b.stat.mtime - a.stat.mtime);
  }
  getRecentClippingNotes() {
    const clippingFolder = this.app.vault.getAbstractFileByPath(this.settings.defaultFolder);
    if (!(clippingFolder instanceof import_obsidian8.TFolder)) {
      return [];
    }
    const files = this.getMarkdownFiles(clippingFolder);
    return files.slice(0, 5);
  }
  updateSettings(settings) {
    this.settings = settings;
  }
};
function createClipButton(container, dropdown, onQuickClip) {
  const wrapper = container.createDiv({ cls: "easy-gate-clip-btn-wrapper" });
  const mainBtn = wrapper.createEl("button", { cls: "easy-gate-clip-btn" });
  mainBtn.textContent = "\u{1F4E5}";
  mainBtn.title = "\uC800\uC7A5 (\uD074\uB9AD: \uC804\uCCB4 \uD398\uC774\uC9C0 \uC800\uC7A5)";
  mainBtn.onclick = (e) => {
    e.preventDefault();
    onQuickClip();
  };
  const dropdownBtn = wrapper.createEl("button", { cls: "easy-gate-clip-dropdown-btn" });
  dropdownBtn.textContent = "\u25BC";
  dropdownBtn.title = "\uC800\uC7A5 \uC635\uC158 \uB354\uBCF4\uAE30";
  dropdownBtn.onclick = (e) => {
    e.preventDefault();
    dropdown.show(e);
  };
  return wrapper;
}

// src/ui/AIDropdown.ts
var import_obsidian9 = require("obsidian");
init_types();
var AIDropdown = class {
  constructor(options) {
    this.app = options.app;
    this.settings = options.settings;
    this.savedPrompts = options.savedPrompts;
    this.onAISummary = options.onAISummary;
    this.onAIWithTemplate = options.onAIWithTemplate;
    this.onAIWithPrompt = options.onAIWithPrompt;
    this.onAISelection = options.onAISelection;
    this.onOpenAnalysisModal = options.onOpenAnalysisModal;
    this.onOpenMultiSourceModal = options.onOpenMultiSourceModal;
    this.onOpenSettings = options.onOpenSettings;
  }
  show(event) {
    const menu = new import_obsidian9.Menu();
    const currentProvider = AI_PROVIDERS[this.settings.provider];
    const hasApiKey = this.hasApiKey(this.settings.provider);
    menu.addItem((item) => item.setTitle(`\u{1F916} ${currentProvider.displayName} ${hasApiKey ? "\u2705" : "\u26A0\uFE0F \uD0A4 \uD544\uC694"}`).setDisabled(true));
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("\u2702\uFE0F \uC120\uD0DD \uC601\uC5ED \uBD84\uC11D").setIcon("scissors").setDisabled(!hasApiKey).onClick(() => {
      this.onAISelection();
    }));
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("\u{1F4CB} \uD15C\uD50C\uB9BF\uC73C\uB85C \uBD84\uC11D").setDisabled(true));
    const templates = [
      { id: "basic-summary", label: "\u{1F4CB} \uAE30\uBCF8 \uC694\uC57D", icon: "file-text" },
      { id: "study-note", label: "\u{1F4DA} \uD559\uC2B5 \uB178\uD2B8", icon: "book" },
      { id: "analysis-report", label: "\u{1F4CA} \uBD84\uC11D \uB9AC\uD3EC\uD2B8", icon: "bar-chart" },
      { id: "idea-note", label: "\u{1F4A1} \uC544\uC774\uB514\uC5B4 \uB178\uD2B8", icon: "lightbulb" },
      { id: "action-items", label: "\u2705 \uC561\uC158 \uC544\uC774\uD15C", icon: "check-square" },
      { id: "qa-format", label: "\u2753 Q&A \uD615\uC2DD", icon: "help-circle" }
    ];
    templates.forEach((template) => {
      menu.addItem((item) => item.setTitle(`  ${template.label}`).setIcon(template.icon).setDisabled(!hasApiKey).onClick(() => {
        this.onOpenAnalysisModal(template.id);
      }));
    });
    if (this.savedPrompts.length > 0) {
      menu.addSeparator();
      menu.addItem((item) => item.setTitle("\uC800\uC7A5\uB41C \uD504\uB86C\uD504\uD2B8").setDisabled(true));
      this.savedPrompts.forEach((prompt2) => {
        menu.addItem((item) => item.setTitle(`  \u{1F4AC} ${prompt2.name}`).setDisabled(!hasApiKey).onClick(() => {
          this.onAIWithPrompt(prompt2.prompt);
        }));
      });
    }
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("\u{1F50D} \uBD84\uC11D \uBAA8\uB2EC \uC5F4\uAE30").setIcon("search").onClick(() => {
      this.onOpenAnalysisModal();
    }));
    menu.addItem((item) => item.setTitle("\u{1F4CA} \uBA40\uD2F0 \uC18C\uC2A4 \uC885\uD569 \uBD84\uC11D").setIcon("layers").setDisabled(!hasApiKey).onClick(() => {
      this.onOpenMultiSourceModal();
    }));
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("Provider \uC120\uD0DD").setDisabled(true));
    const providers = Object.values(AI_PROVIDERS);
    providers.forEach((provider) => {
      const isConfigured = this.hasApiKey(provider.id);
      const isSelected = this.settings.provider === provider.id;
      menu.addItem((item) => item.setTitle(`  ${isSelected ? "\u25CF " : "\u25CB "}${provider.displayName} ${isConfigured ? "\u2705" : ""}`).setDisabled(!isConfigured).onClick(() => {
        if (isConfigured) {
          this.onProviderChange(provider.id);
        }
      }));
    });
    menu.addSeparator();
    menu.addItem((item) => item.setTitle("\u2699\uFE0F API \uD0A4 \uC124\uC815...").setIcon("settings").onClick(() => {
      this.onOpenSettings();
    }));
    if (event instanceof MouseEvent) {
      menu.showAtMouseEvent(event);
    } else {
      const rect = event.getBoundingClientRect();
      menu.showAtPosition({ x: rect.left, y: rect.bottom });
    }
  }
  hasApiKey(providerId) {
    const key = this.settings.apiKeys[providerId];
    return !!key && key.trim().length > 0;
  }
  onProviderChange(providerId) {
    console.log("[AIDropdown] Provider changed to:", providerId);
  }
  updateSettings(settings, savedPrompts) {
    this.settings = settings;
    this.savedPrompts = savedPrompts;
  }
};
function createAIButton(container, dropdown, onOpenAnalysisModal, hasApiKey) {
  const wrapper = container.createDiv({ cls: "easy-gate-ai-btn-wrapper" });
  const mainBtn = wrapper.createEl("button", { cls: "easy-gate-ai-btn" });
  mainBtn.textContent = "\u{1F916}";
  mainBtn.title = hasApiKey ? "AI \uBD84\uC11D \uBAA8\uB2EC \uC5F4\uAE30 (\uD14D\uC2A4\uD2B8 \uC785\uB825/\uD3B8\uC9D1)" : "API \uD0A4 \uD544\uC694";
  if (!hasApiKey) {
    mainBtn.style.opacity = "0.5";
    mainBtn.style.cursor = "not-allowed";
  }
  mainBtn.onclick = (e) => {
    e.preventDefault();
    if (hasApiKey) {
      onOpenAnalysisModal();
    }
  };
  const dropdownBtn = wrapper.createEl("button", { cls: "easy-gate-ai-dropdown-btn" });
  dropdownBtn.textContent = "\u25BC";
  dropdownBtn.title = "AI \uBD84\uC11D \uC635\uC158 \uB354\uBCF4\uAE30";
  dropdownBtn.onclick = (e) => {
    e.preventDefault();
    dropdown.show(e);
  };
  return wrapper;
}

// src/GateView.ts
init_clipping();

// src/modals/AnalysisModal.ts
var import_obsidian11 = require("obsidian");
init_types();
var ANALYSIS_TEMPLATES = [
  {
    id: "basic-summary",
    name: "\u{1F4CB} \uAE30\uBCF8 \uC694\uC57D",
    description: "\uD398\uC774\uC9C0 \uB0B4\uC6A9\uC744 \uAC04\uACB0\uD558\uAC8C \uC694\uC57D\uD569\uB2C8\uB2E4.",
    icon: "file-text",
    prompt: `\uB2E4\uC74C \uC6F9 \uD398\uC774\uC9C0 \uB0B4\uC6A9\uC744 \uD55C\uAD6D\uC5B4\uB85C \uC694\uC57D\uD574\uC8FC\uC138\uC694:

## \uC694\uC57D \uC694\uAD6C\uC0AC\uD56D
- \uD575\uC2EC \uB0B4\uC6A9\uC744 3-5\uAC1C\uC758 \uC8FC\uC694 \uD3EC\uC778\uD2B8\uB85C \uC815\uB9AC
- \uC911\uC694\uD55C \uC815\uBCF4\uC640 \uACB0\uB860\uC744 \uAC15\uC870
- \uC804\uBB38 \uC6A9\uC5B4\uB294 \uAC04\uB2E8\uD788 \uC124\uBA85 \uCD94\uAC00

## \uC6D0\uBCF8 \uB0B4\uC6A9
{content}`
  },
  {
    id: "study-note",
    name: "\u{1F4DA} \uD559\uC2B5 \uB178\uD2B8",
    description: "\uD559\uC2B5\uC5D0 \uCD5C\uC801\uD654\uB41C \uD615\uD0DC\uB85C \uC815\uB9AC\uD569\uB2C8\uB2E4.",
    icon: "book",
    prompt: `\uB2E4\uC74C \uB0B4\uC6A9\uC744 \uD559\uC2B5 \uB178\uD2B8 \uD615\uD0DC\uB85C \uC815\uB9AC\uD574\uC8FC\uC138\uC694:

## \uC815\uB9AC \uD615\uC2DD
1. **\uD575\uC2EC \uAC1C\uB150**: \uC8FC\uC694 \uAC1C\uB150\uACFC \uC815\uC758
2. **\uC911\uC694 \uD3EC\uC778\uD2B8**: \uAE30\uC5B5\uD574\uC57C \uD560 \uD575\uC2EC \uC0AC\uD56D
3. **\uC608\uC2DC/\uC0AC\uB840**: \uC774\uD574\uB97C \uB3D5\uB294 \uAD6C\uCCB4\uC801 \uC608\uC2DC
4. **\uC9C8\uBB38 & \uB2F5\uBCC0**: \uC790\uC8FC \uBB3B\uB294 \uC9C8\uBB38 \uD615\uD0DC\uB85C \uC815\uB9AC
5. **\uBCF5\uC2B5 \uD0A4\uC6CC\uB4DC**: \uBCF5\uC2B5\uC6A9 \uD0A4\uC6CC\uB4DC \uBAA9\uB85D

## \uC6D0\uBCF8 \uB0B4\uC6A9
{content}`
  },
  {
    id: "analysis-report",
    name: "\u{1F4CA} \uBD84\uC11D \uB9AC\uD3EC\uD2B8",
    description: "\uC2EC\uCE35 \uBD84\uC11D \uB9AC\uD3EC\uD2B8\uB97C \uC0DD\uC131\uD569\uB2C8\uB2E4.",
    icon: "bar-chart",
    prompt: `\uB2E4\uC74C \uB0B4\uC6A9\uC744 \uBD84\uC11D \uB9AC\uD3EC\uD2B8 \uD615\uD0DC\uB85C \uC791\uC131\uD574\uC8FC\uC138\uC694:

## \uB9AC\uD3EC\uD2B8 \uAD6C\uC870
1. **\uAC1C\uC694**: \uBB38\uC11C\uC758 \uD575\uC2EC \uC8FC\uC81C\uC640 \uBAA9\uC801
2. **\uC8FC\uC694 \uBC1C\uACAC\uC0AC\uD56D**: \uC911\uC694\uD55C \uC815\uBCF4\uC640 \uB370\uC774\uD130
3. **\uBD84\uC11D**: \uB0B4\uC6A9\uC5D0 \uB300\uD55C \uC2EC\uCE35 \uBD84\uC11D
4. **\uC2DC\uC0AC\uC810**: \uB3C4\uCD9C\uD560 \uC218 \uC788\uB294 \uC778\uC0AC\uC774\uD2B8
5. **\uACB0\uB860 \uBC0F \uC81C\uC548**: \uCD5C\uC885 \uACB0\uB860\uACFC \uD65C\uC6A9 \uBC29\uC548

## \uC6D0\uBCF8 \uB0B4\uC6A9
{content}`
  },
  {
    id: "idea-note",
    name: "\u{1F4A1} \uC544\uC774\uB514\uC5B4 \uB178\uD2B8",
    description: "\uC544\uC774\uB514\uC5B4 \uBC1C\uAD74 \uBC0F \uD655\uC7A5\uC5D0 \uCD08\uC810\uC744 \uB9DE\uCDA5\uB2C8\uB2E4.",
    icon: "lightbulb",
    prompt: `\uB2E4\uC74C \uB0B4\uC6A9\uC5D0\uC11C \uC544\uC774\uB514\uC5B4\uB97C \uBC1C\uAD74\uD558\uACE0 \uD655\uC7A5\uD574\uC8FC\uC138\uC694:

## \uC544\uC774\uB514\uC5B4 \uC815\uB9AC
1. **\uD575\uC2EC \uC544\uC774\uB514\uC5B4**: \uBB38\uC11C\uC758 \uC911\uC2EC \uC544\uC774\uB514\uC5B4
2. **\uAD00\uB828 \uC544\uC774\uB514\uC5B4**: \uC5F0\uAD00\uB41C \uCD94\uAC00 \uC544\uC774\uB514\uC5B4
3. **\uC801\uC6A9 \uBC29\uC548**: \uC2E4\uC81C \uC801\uC6A9\uD560 \uC218 \uC788\uB294 \uBC29\uBC95
4. **\uBC1C\uC804 \uAC00\uB2A5\uC131**: \uB354 \uBC1C\uC804\uC2DC\uD0AC \uC218 \uC788\uB294 \uBC29\uD5A5
5. **\uC5F0\uACB0\uC810**: \uB2E4\uB978 \uBD84\uC57C\uC640\uC758 \uC5F0\uACB0 \uAC00\uB2A5\uC131

## \uC6D0\uBCF8 \uB0B4\uC6A9
{content}`
  },
  {
    id: "action-items",
    name: "\u2705 \uC561\uC158 \uC544\uC774\uD15C",
    description: "\uC2E4\uD589 \uAC00\uB2A5\uD55C \uD0DC\uC2A4\uD06C \uBAA9\uB85D\uC744 \uCD94\uCD9C\uD569\uB2C8\uB2E4.",
    icon: "check-square",
    prompt: `\uB2E4\uC74C \uB0B4\uC6A9\uC5D0\uC11C \uC2E4\uD589 \uAC00\uB2A5\uD55C \uC561\uC158 \uC544\uC774\uD15C\uC744 \uCD94\uCD9C\uD574\uC8FC\uC138\uC694:

## \uC561\uC158 \uC544\uC774\uD15C \uD615\uC2DD
- [ ] \uC989\uC2DC \uC2E4\uD589 \uAC00\uB2A5\uD55C \uD0DC\uC2A4\uD06C
- [ ] \uB2E8\uAE30 \uBAA9\uD45C (1\uC8FC\uC77C \uB0B4)
- [ ] \uC911\uAE30 \uBAA9\uD45C (1\uAC1C\uC6D4 \uB0B4)
- [ ] \uC7A5\uAE30 \uBAA9\uD45C

\uAC01 \uD56D\uBAA9\uC5D0 \uC6B0\uC120\uC21C\uC704\uC640 \uC608\uC0C1 \uC18C\uC694\uC2DC\uAC04\uC744 \uCD94\uAC00\uD574\uC8FC\uC138\uC694.

## \uC6D0\uBCF8 \uB0B4\uC6A9
{content}`
  },
  {
    id: "qa-format",
    name: "\u2753 Q&A \uD615\uC2DD",
    description: "\uC9C8\uBB38\uACFC \uB2F5\uBCC0 \uD615\uD0DC\uB85C \uC7AC\uAD6C\uC131\uD569\uB2C8\uB2E4.",
    icon: "help-circle",
    prompt: `\uB2E4\uC74C \uB0B4\uC6A9\uC744 Q&A \uD615\uC2DD\uC73C\uB85C \uC7AC\uAD6C\uC131\uD574\uC8FC\uC138\uC694:

## Q&A \uD615\uC2DD
Q1: [\uD575\uC2EC \uC9C8\uBB38]
A1: [\uC0C1\uC138\uD55C \uB2F5\uBCC0]

Q2: ...

\uCD5C\uC18C 5\uAC1C\uC758 Q&A \uC30D\uC744 \uC0DD\uC131\uD558\uACE0,
\uB0B4\uC6A9\uC758 \uD575\uC2EC\uC744 \uD30C\uC545\uD560 \uC218 \uC788\uB294 \uC9C8\uBB38\uC744 \uB9CC\uB4E4\uC5B4\uC8FC\uC138\uC694.

## \uC6D0\uBCF8 \uB0B4\uC6A9
{content}`
  }
];
var AnalysisModal = class extends import_obsidian11.Modal {
  constructor(options) {
    super(options.app);
    this.selectedTemplateId = "basic-summary";
    this.customPrompt = "";
    this.includeMetadata = true;
    this.outputFormat = "markdown";
    this.editableContent = "";
    this.promptTextArea = null;
    this.templateContainer = null;
    this.contentTextArea = null;
    this.statsContainer = null;
    this.settings = options.settings;
    this.savedPrompts = options.savedPrompts;
    this.clipData = options.clipData;
    this.onAnalyze = options.onAnalyze;
    this.onSavePrompt = options.onSavePrompt;
    this.selectedProvider = options.settings.provider;
    this.editableContent = options.initialText || options.clipData.content || "";
    if (options.initialTemplateId) {
      this.selectedTemplateId = options.initialTemplateId;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("easy-gate-analysis-modal");
    this.modalEl.style.width = "700px";
    this.modalEl.style.maxWidth = "90vw";
    this.renderHeader();
    this.renderContentPreview();
    this.renderTemplateSelection();
    this.renderCustomPrompt();
    this.renderOptions();
    this.renderActions();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  renderHeader() {
    const { contentEl } = this;
    const header = contentEl.createDiv({ cls: "analysis-modal-header" });
    header.createEl("h2", { text: "\u{1F50D} \uD398\uC774\uC9C0 \uBD84\uC11D" });
    const pageInfo = header.createDiv({ cls: "page-info" });
    pageInfo.createEl("span", { text: "\u{1F4C4} " + this.clipData.title, cls: "page-title" });
    if (this.clipData.url) {
      const urlSpan = pageInfo.createEl("span", { cls: "page-url" });
      urlSpan.createEl("a", {
        text: this.truncateUrl(this.clipData.url, 50),
        href: this.clipData.url
      });
    }
  }
  renderContentPreview() {
    const { contentEl } = this;
    const previewSection = contentEl.createDiv({ cls: "analysis-section preview-section" });
    const headerRow = previewSection.createDiv({ cls: "content-header-row" });
    headerRow.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        `;
    headerRow.createEl("h3", { text: "\u270F\uFE0F \uBD84\uC11D\uD560 \uD14D\uC2A4\uD2B8" });
    const pasteBtn = headerRow.createEl("button", {
      text: "\u{1F4CB} \uD074\uB9BD\uBCF4\uB4DC\uC5D0\uC11C \uBD99\uC5EC\uB123\uAE30",
      cls: "paste-btn"
    });
    pasteBtn.style.cssText = `
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 4px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            cursor: pointer;
            transition: all 0.2s;
        `;
    pasteBtn.onclick = async () => {
      try {
        const text = await navigator.clipboard.readText();
        if (text && this.contentTextArea) {
          this.editableContent = text;
          this.contentTextArea.setValue(text);
          this.updateContentStats();
          showSuccess("\uD074\uB9BD\uBCF4\uB4DC\uC5D0\uC11C \uD14D\uC2A4\uD2B8\uB97C \uBD99\uC5EC\uB123\uC5C8\uC2B5\uB2C8\uB2E4.");
        }
      } catch (err) {
        showWarning("\uD074\uB9BD\uBCF4\uB4DC\uC5D0\uC11C \uD14D\uC2A4\uD2B8\uB97C \uAC00\uC838\uC62C \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      }
    };
    const guide = previewSection.createEl("p", { cls: "content-guide" });
    guide.style.cssText = `
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 10px;
        `;
    guide.textContent = "\uBD84\uC11D\uD560 \uD14D\uC2A4\uD2B8\uB97C \uC9C1\uC811 \uC785\uB825\uD558\uAC70\uB098, \uC120\uD0DD\uD55C \uD14D\uC2A4\uD2B8\uB97C \uD3B8\uC9D1\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.";
    const textAreaContainer = previewSection.createDiv({ cls: "content-textarea-container" });
    new import_obsidian11.Setting(textAreaContainer).setClass("content-textarea-setting").addTextArea((text) => {
      this.contentTextArea = text;
      text.setPlaceholder("\uBD84\uC11D\uD560 \uD14D\uC2A4\uD2B8\uB97C \uC5EC\uAE30\uC5D0 \uC785\uB825\uD558\uAC70\uB098 \uBD99\uC5EC\uB123\uC73C\uC138\uC694...\n\n\u{1F4A1} \uD301: \uC6F9\uD398\uC774\uC9C0\uC5D0\uC11C \uD14D\uC2A4\uD2B8\uB97C \uB4DC\uB798\uADF8\uD558\uC5EC \uC120\uD0DD\uD55C \uD6C4 \uC774 \uBAA8\uB2EC\uC744 \uC5F4\uBA74 \uC790\uB3D9\uC73C\uB85C \uD45C\uC2DC\uB429\uB2C8\uB2E4.");
      text.setValue(this.editableContent);
      text.inputEl.style.cssText = `
                    width: 100%;
                    min-height: 150px;
                    max-height: 250px;
                    resize: vertical;
                    font-size: 13px;
                    line-height: 1.5;
                    padding: 12px;
                    border-radius: 8px;
                    border: 1px solid var(--background-modifier-border);
                    background: var(--background-primary);
                `;
      text.onChange((value) => {
        this.editableContent = value;
        this.updateContentStats();
      });
    });
    this.statsContainer = previewSection.createDiv({ cls: "content-stats" });
    this.statsContainer.style.cssText = `
            display: flex;
            gap: 16px;
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-muted);
        `;
    this.updateContentStats();
  }
  updateContentStats() {
    if (!this.statsContainer)
      return;
    const content = this.editableContent;
    const contentLength = content.length;
    const wordCount = content.split(/\s+/).filter((w) => w).length;
    const tokenEstimate = Math.ceil(contentLength / 4);
    this.statsContainer.empty();
    this.statsContainer.createSpan({ text: `\u{1F4CA} ${contentLength.toLocaleString()} \uC790` });
    this.statsContainer.createSpan({ text: `\u{1F4DD} ${wordCount.toLocaleString()} \uB2E8\uC5B4` });
    this.statsContainer.createSpan({ text: `\u{1F3AB} ~${tokenEstimate.toLocaleString()} \uD1A0\uD070` });
    if (contentLength === 0) {
      this.statsContainer.createSpan({
        text: "\u26A0\uFE0F \uBD84\uC11D\uD560 \uD14D\uC2A4\uD2B8\uB97C \uC785\uB825\uD558\uC138\uC694",
        cls: "stats-warning"
      });
    }
  }
  renderTemplateSelection() {
    const { contentEl } = this;
    const templateSection = contentEl.createDiv({ cls: "analysis-section template-section" });
    templateSection.createEl("h3", { text: "\u{1F4CB} \uBD84\uC11D \uD15C\uD50C\uB9BF" });
    this.templateContainer = templateSection.createDiv({ cls: "template-grid" });
    this.templateContainer.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 12px;
        `;
    ANALYSIS_TEMPLATES.forEach((template) => {
      this.createTemplateCard(template);
    });
    if (this.savedPrompts.length > 0) {
      const customSection = templateSection.createDiv({ cls: "saved-prompts-section" });
      customSection.style.marginTop = "16px";
      customSection.createEl("h4", { text: "\u{1F4BE} \uC800\uC7A5\uB41C \uD504\uB86C\uD504\uD2B8", cls: "saved-prompts-title" });
      const savedGrid = customSection.createDiv({ cls: "saved-prompts-grid" });
      savedGrid.style.cssText = `
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 8px;
            `;
      this.savedPrompts.forEach((prompt2) => {
        const chip = savedGrid.createEl("button", {
          text: `\u{1F4AC} ${prompt2.name}`,
          cls: "saved-prompt-chip"
        });
        chip.style.cssText = `
                    padding: 6px 12px;
                    border-radius: 16px;
                    border: 1px solid var(--background-modifier-border);
                    background: var(--background-secondary);
                    cursor: pointer;
                    font-size: 12px;
                    transition: all 0.2s;
                `;
        chip.onclick = () => {
          this.selectedTemplateId = null;
          this.customPrompt = prompt2.prompt;
          if (this.promptTextArea) {
            this.promptTextArea.setValue(prompt2.prompt);
          }
          this.updateTemplateSelection();
        };
      });
    }
  }
  createTemplateCard(template) {
    if (!this.templateContainer)
      return;
    const card = this.templateContainer.createDiv({ cls: "template-card" });
    card.style.cssText = `
            padding: 12px;
            border-radius: 8px;
            border: 2px solid var(--background-modifier-border);
            background: var(--background-primary);
            cursor: pointer;
            transition: all 0.2s;
        `;
    if (this.selectedTemplateId === template.id) {
      card.style.borderColor = "var(--interactive-accent)";
      card.style.background = "var(--background-secondary)";
    }
    const title = card.createDiv({ cls: "template-title" });
    title.style.cssText = `font-weight: 600; margin-bottom: 4px;`;
    title.textContent = template.name;
    const desc = card.createDiv({ cls: "template-desc" });
    desc.style.cssText = `font-size: 11px; color: var(--text-muted);`;
    desc.textContent = template.description;
    card.onclick = () => {
      this.selectedTemplateId = template.id;
      this.customPrompt = "";
      if (this.promptTextArea) {
        this.promptTextArea.setValue("");
      }
      this.updateTemplateSelection();
    };
    card.onmouseenter = () => {
      if (this.selectedTemplateId !== template.id) {
        card.style.borderColor = "var(--interactive-accent-hover)";
      }
    };
    card.onmouseleave = () => {
      if (this.selectedTemplateId !== template.id) {
        card.style.borderColor = "var(--background-modifier-border)";
      }
    };
  }
  updateTemplateSelection() {
    if (!this.templateContainer)
      return;
    const cards = this.templateContainer.querySelectorAll(".template-card");
    cards.forEach((card, index) => {
      const htmlCard = card;
      const template = ANALYSIS_TEMPLATES[index];
      if (template && this.selectedTemplateId === template.id) {
        htmlCard.style.borderColor = "var(--interactive-accent)";
        htmlCard.style.background = "var(--background-secondary)";
      } else {
        htmlCard.style.borderColor = "var(--background-modifier-border)";
        htmlCard.style.background = "var(--background-primary)";
      }
    });
  }
  renderCustomPrompt() {
    const { contentEl } = this;
    const promptSection = contentEl.createDiv({ cls: "analysis-section prompt-section" });
    promptSection.createEl("h3", { text: "\u270F\uFE0F \uCEE4\uC2A4\uD140 \uD504\uB86C\uD504\uD2B8 (\uC120\uD0DD\uC0AC\uD56D)" });
    const promptDesc = promptSection.createEl("p", { cls: "prompt-description" });
    promptDesc.style.cssText = `font-size: 12px; color: var(--text-muted); margin-bottom: 8px;`;
    promptDesc.textContent = "\uD15C\uD50C\uB9BF \uB300\uC2E0 \uC9C1\uC811 \uD504\uB86C\uD504\uD2B8\uB97C \uC785\uB825\uD558\uAC70\uB098, \uCD94\uAC00 \uC9C0\uC2DC\uC0AC\uD56D\uC744 \uC791\uC131\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.";
    new import_obsidian11.Setting(promptSection).setClass("custom-prompt-setting").addTextArea((text) => {
      this.promptTextArea = text;
      text.setPlaceholder('\uC608: "\uC704 \uB0B4\uC6A9\uC744 \uCD08\uB4F1\uD559\uC0DD\uB3C4 \uC774\uD574\uD560 \uC218 \uC788\uAC8C \uC27D\uAC8C \uC124\uBA85\uD574\uC8FC\uC138\uC694..."');
      text.setValue(this.customPrompt);
      text.inputEl.style.cssText = `
                    width: 100%;
                    min-height: 80px;
                    resize: vertical;
                `;
      text.onChange((value) => {
        this.customPrompt = value;
        if (value.trim()) {
          this.selectedTemplateId = null;
          this.updateTemplateSelection();
        }
      });
    });
    if (this.onSavePrompt) {
      const savePromptBtn = promptSection.createEl("button", {
        text: "\u{1F4BE} \uC774 \uD504\uB86C\uD504\uD2B8 \uC800\uC7A5",
        cls: "save-prompt-btn"
      });
      savePromptBtn.style.cssText = `
                margin-top: 8px;
                padding: 6px 12px;
                font-size: 12px;
                border-radius: 4px;
                border: 1px solid var(--background-modifier-border);
                background: var(--background-secondary);
                cursor: pointer;
            `;
      savePromptBtn.onclick = () => this.saveCurrentPrompt();
    }
  }
  renderOptions() {
    const { contentEl } = this;
    const optionsSection = contentEl.createDiv({ cls: "analysis-section options-section" });
    optionsSection.createEl("h3", { text: "\u2699\uFE0F \uBD84\uC11D \uC635\uC158" });
    new import_obsidian11.Setting(optionsSection).setName("AI Provider").setDesc("\uBD84\uC11D\uC5D0 \uC0AC\uC6A9\uD560 AI \uC11C\uBE44\uC2A4\uB97C \uC120\uD0DD\uD569\uB2C8\uB2E4.").addDropdown((dropdown) => {
      const aiService = getAIService();
      Object.entries(AI_PROVIDERS).forEach(([key, provider]) => {
        var _a;
        const isConfigured = (_a = aiService == null ? void 0 : aiService.isProviderConfigured(key)) != null ? _a : false;
        dropdown.addOption(key, `${provider.displayName} ${isConfigured ? "\u2705" : "\u26A0\uFE0F"}`);
      });
      dropdown.setValue(this.selectedProvider);
      dropdown.onChange((value) => {
        this.selectedProvider = value;
      });
    });
    new import_obsidian11.Setting(optionsSection).setName("\uCD9C\uB825 \uD615\uC2DD").setDesc("\uBD84\uC11D \uACB0\uACFC\uC758 \uD615\uC2DD\uC744 \uC120\uD0DD\uD569\uB2C8\uB2E4.").addDropdown((dropdown) => {
      dropdown.addOption("markdown", "\u{1F4C4} \uB9C8\uD06C\uB2E4\uC6B4");
      dropdown.addOption("summary", "\u{1F4CB} \uC694\uC57D (\uC9E7\uC740 \uD615\uD0DC)");
      dropdown.addOption("bullets", "\u2022 \uAE00\uBA38\uB9AC \uAE30\uD638");
      dropdown.addOption("qa", "\u2753 Q&A \uD615\uC2DD");
      dropdown.setValue(this.outputFormat);
      dropdown.onChange((value) => {
        this.outputFormat = value;
      });
    });
    new import_obsidian11.Setting(optionsSection).setName("\uBA54\uD0C0\uB370\uC774\uD130 \uD3EC\uD568").setDesc("URL, \uC791\uC131\uC790, \uB0A0\uC9DC \uB4F1\uC758 \uBA54\uD0C0\uB370\uC774\uD130\uB97C \uB178\uD2B8\uC5D0 \uD3EC\uD568\uD569\uB2C8\uB2E4.").addToggle((toggle) => {
      toggle.setValue(this.includeMetadata);
      toggle.onChange((value) => {
        this.includeMetadata = value;
      });
    });
  }
  renderActions() {
    const { contentEl } = this;
    const actionsSection = contentEl.createDiv({ cls: "analysis-actions" });
    actionsSection.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--background-modifier-border);
        `;
    const cancelBtn = actionsSection.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "mod-cancel"
    });
    cancelBtn.style.cssText = `
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            cursor: pointer;
        `;
    cancelBtn.onclick = () => this.close();
    const analyzeBtn = actionsSection.createEl("button", {
      text: "\u{1F680} \uBD84\uC11D \uC2DC\uC791",
      cls: "mod-cta"
    });
    analyzeBtn.style.cssText = `
            padding: 8px 20px;
            border-radius: 4px;
            border: none;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            cursor: pointer;
            font-weight: 600;
        `;
    analyzeBtn.onclick = () => this.startAnalysis();
  }
  async startAnalysis() {
    if (!this.editableContent.trim()) {
      showWarning("\uBD84\uC11D\uD560 \uD14D\uC2A4\uD2B8\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    if (!this.selectedTemplateId && !this.customPrompt.trim()) {
      showWarning("\uD15C\uD50C\uB9BF\uC744 \uC120\uD0DD\uD558\uAC70\uB098 \uCEE4\uC2A4\uD140 \uD504\uB86C\uD504\uD2B8\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    const aiService = getAIService();
    if (!(aiService == null ? void 0 : aiService.isProviderConfigured(this.selectedProvider))) {
      showWarning(`${AI_PROVIDERS[this.selectedProvider].displayName} API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.`);
      return;
    }
    const config = {
      templateId: this.selectedTemplateId,
      customPrompt: this.customPrompt.trim() || null,
      provider: this.selectedProvider,
      includeMetadata: this.includeMetadata,
      outputFormat: this.outputFormat,
      language: this.settings.defaultLanguage || "ko"
    };
    this.close();
    await this.onAnalyze(config, this.editableContent.trim());
  }
  saveCurrentPrompt() {
    if (!this.customPrompt.trim()) {
      showWarning("\uC800\uC7A5\uD560 \uD504\uB86C\uD504\uD2B8\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    const promptName = prompt("\uD504\uB86C\uD504\uD2B8 \uC774\uB984\uC744 \uC785\uB825\uD558\uC138\uC694:");
    if (!promptName)
      return;
    const newPrompt = {
      id: `custom-${Date.now()}`,
      name: promptName,
      prompt: this.customPrompt
    };
    if (this.onSavePrompt) {
      this.onSavePrompt(newPrompt);
      showSuccess(`"${promptName}" \uD504\uB86C\uD504\uD2B8\uAC00 \uC800\uC7A5\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
    }
  }
  truncateUrl(url, maxLength) {
    if (url.length <= maxLength)
      return url;
    return url.substring(0, maxLength - 3) + "...";
  }
  static getTemplatePrompt(templateId) {
    const template = ANALYSIS_TEMPLATES.find((t) => t.id === templateId);
    return (template == null ? void 0 : template.prompt) || null;
  }
  static getTemplates() {
    return ANALYSIS_TEMPLATES;
  }
};

// src/modals/ProcessModal.ts
var import_obsidian12 = require("obsidian");
init_types();
var ProcessModal = class extends import_obsidian12.Modal {
  constructor(options) {
    super(options.app);
    this.state = "preparing";
    this.resultContent = "";
    this.errorMessage = "";
    this.startTime = 0;
    this.endTime = 0;
    this.statusEl = null;
    this.progressEl = null;
    this.resultEl = null;
    this.actionsEl = null;
    this.clipData = options.clipData;
    this.config = options.config;
    this.onSave = options.onSave;
    this.onAppend = options.onAppend;
    this.renderComponent = new import_obsidian12.Component();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("easy-gate-process-modal");
    this.renderComponent.load();
    this.modalEl.style.width = "600px";
    this.modalEl.style.maxWidth = "90vw";
    this.renderHeader();
    this.renderStatus();
    this.renderProgress();
    this.renderResult();
    this.renderActions();
    this.startProcessing();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.renderComponent.unload();
  }
  renderHeader() {
    const { contentEl } = this;
    const header = contentEl.createDiv({ cls: "process-modal-header" });
    header.createEl("h2", { text: "\u{1F916} AI \uBD84\uC11D \uCC98\uB9AC \uC911" });
    const providerInfo = header.createDiv({ cls: "provider-info" });
    providerInfo.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 13px;
            color: var(--text-muted);
        `;
    const provider = AI_PROVIDERS[this.config.provider];
    providerInfo.createSpan({ text: `\u{1F527} ${provider.displayName}` });
    providerInfo.createSpan({ text: "|" });
    const template = AnalysisModal.getTemplates().find((t) => t.id === this.config.templateId);
    const templateName = (template == null ? void 0 : template.name) || "\uCEE4\uC2A4\uD140 \uD504\uB86C\uD504\uD2B8";
    providerInfo.createSpan({ text: `\u{1F4CB} ${templateName}` });
  }
  renderStatus() {
    const { contentEl } = this;
    this.statusEl = contentEl.createDiv({ cls: "process-status" });
    this.statusEl.style.cssText = `
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: var(--background-secondary);
            border-radius: 8px;
            margin: 16px 0;
        `;
    this.updateStatus();
  }
  updateStatus() {
    if (!this.statusEl)
      return;
    this.statusEl.empty();
    const statusConfig = {
      preparing: { icon: "\u23F3", text: "\uC900\uBE44 \uC911...", color: "var(--text-muted)" },
      processing: { icon: "\u{1F504}", text: "AI\uAC00 \uBD84\uC11D \uC911\uC785\uB2C8\uB2E4...", color: "var(--text-accent)" },
      completed: { icon: "\u2705", text: "\uBD84\uC11D \uC644\uB8CC!", color: "var(--color-green)" },
      error: { icon: "\u274C", text: "\uC624\uB958 \uBC1C\uC0DD", color: "var(--color-red)" }
    };
    const config = statusConfig[this.state];
    const iconEl = this.statusEl.createSpan({ text: config.icon });
    iconEl.style.fontSize = "24px";
    const textEl = this.statusEl.createSpan({ text: config.text });
    textEl.style.cssText = `font-size: 16px; font-weight: 500; color: ${config.color};`;
    if (this.state === "completed" && this.endTime) {
      const duration = ((this.endTime - this.startTime) / 1e3).toFixed(1);
      const timeEl = this.statusEl.createSpan({ text: `\u23F1\uFE0F ${duration}\uCD08` });
      timeEl.style.cssText = `margin-left: auto; font-size: 13px; color: var(--text-muted);`;
    }
  }
  renderProgress() {
    const { contentEl } = this;
    this.progressEl = contentEl.createDiv({ cls: "process-progress" });
    this.progressEl.style.cssText = `
            height: 4px;
            background: var(--background-modifier-border);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 16px;
        `;
    const bar = this.progressEl.createDiv({ cls: "progress-bar" });
    bar.style.cssText = `
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--interactive-accent), var(--interactive-accent-hover));
            border-radius: 2px;
            transition: width 0.3s ease;
        `;
  }
  updateProgress(percent) {
    if (!this.progressEl)
      return;
    const bar = this.progressEl.querySelector(".progress-bar");
    if (bar) {
      bar.style.width = `${Math.min(100, percent)}%`;
    }
  }
  renderResult() {
    const { contentEl } = this;
    this.resultEl = contentEl.createDiv({ cls: "process-result" });
    this.resultEl.style.cssText = `
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            padding: 16px;
            background: var(--background-primary);
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        `;
    const loadingEl = this.resultEl.createDiv({ cls: "loading-indicator" });
    loadingEl.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 150px;
            color: var(--text-muted);
        `;
    loadingEl.createSpan({ text: "\u{1F504}" }).style.cssText = "font-size: 32px; animation: spin 1s linear infinite;";
    loadingEl.createSpan({ text: "AI \uC751\uB2F5 \uB300\uAE30 \uC911..." }).style.marginTop = "12px";
    const style = document.createElement("style");
    style.textContent = `
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
        `;
    document.head.appendChild(style);
  }
  async updateResult(content) {
    if (!this.resultEl)
      return;
    this.resultEl.empty();
    await import_obsidian12.MarkdownRenderer.renderMarkdown(content, this.resultEl, "", this.renderComponent);
  }
  renderActions() {
    const { contentEl } = this;
    this.actionsEl = contentEl.createDiv({ cls: "process-actions" });
    this.actionsEl.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--background-modifier-border);
        `;
    const cancelBtn = this.actionsEl.createEl("button", {
      text: "\uCDE8\uC18C",
      cls: "mod-cancel"
    });
    cancelBtn.style.cssText = `
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            cursor: pointer;
        `;
    cancelBtn.onclick = () => this.close();
  }
  updateActionsForCompletion() {
    if (!this.actionsEl)
      return;
    this.actionsEl.empty();
    const closeBtn = this.actionsEl.createEl("button", {
      text: "\uB2EB\uAE30",
      cls: "mod-cancel"
    });
    closeBtn.style.cssText = `
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            cursor: pointer;
        `;
    closeBtn.onclick = () => this.close();
    const copyBtn = this.actionsEl.createEl("button", {
      text: "\u{1F4CB} \uBCF5\uC0AC",
      cls: "mod-secondary"
    });
    copyBtn.style.cssText = `
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            cursor: pointer;
        `;
    copyBtn.onclick = async () => {
      await navigator.clipboard.writeText(this.resultContent);
      showSuccess("\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
    };
    const saveBtn = this.actionsEl.createEl("button", {
      text: "\u{1F4BE} \uC0C8 \uB178\uD2B8\uB85C \uC800\uC7A5",
      cls: "mod-cta"
    });
    saveBtn.style.cssText = `
            padding: 8px 20px;
            border-radius: 4px;
            border: none;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            cursor: pointer;
            font-weight: 600;
        `;
    saveBtn.onclick = async () => {
      await this.saveAsNote();
    };
  }
  updateActionsForError() {
    if (!this.actionsEl)
      return;
    this.actionsEl.empty();
    const closeBtn = this.actionsEl.createEl("button", {
      text: "\uB2EB\uAE30",
      cls: "mod-cancel"
    });
    closeBtn.style.cssText = `
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-secondary);
            cursor: pointer;
        `;
    closeBtn.onclick = () => this.close();
    const retryBtn = this.actionsEl.createEl("button", {
      text: "\u{1F504} \uC7AC\uC2DC\uB3C4",
      cls: "mod-cta"
    });
    retryBtn.style.cssText = `
            padding: 8px 20px;
            border-radius: 4px;
            border: none;
            background: var(--interactive-accent);
            color: var(--text-on-accent);
            cursor: pointer;
            font-weight: 600;
        `;
    retryBtn.onclick = () => {
      this.state = "preparing";
      this.resultContent = "";
      this.errorMessage = "";
      this.updateStatus();
      this.renderResult();
      this.renderActions();
      this.startProcessing();
    };
  }
  async startProcessing() {
    this.startTime = Date.now();
    this.state = "preparing";
    this.updateStatus();
    this.updateProgress(10);
    try {
      const aiService = getAIService();
      if (!aiService) {
        throw new Error("AI Service\uAC00 \uCD08\uAE30\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      }
      const prompt2 = this.buildPrompt();
      this.state = "processing";
      this.updateStatus();
      this.updateProgress(30);
      this.updateProgress(50);
      const response = await aiService.generateTextWithProvider(this.config.provider, [{ role: "user", content: prompt2 }], { temperature: 0.7, maxTokens: 4e3 });
      const fullContent = response.content;
      this.resultContent = fullContent;
      await this.updateResult(fullContent);
      this.updateProgress(90);
      this.endTime = Date.now();
      this.state = "completed";
      this.updateStatus();
      this.updateProgress(100);
      this.updateActionsForCompletion();
    } catch (error) {
      this.endTime = Date.now();
      this.state = "error";
      this.errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      this.updateStatus();
      this.showError(this.errorMessage);
      this.updateActionsForError();
    }
  }
  buildPrompt() {
    var _a, _b, _c;
    let basePrompt = "";
    if (this.config.templateId) {
      basePrompt = AnalysisModal.getTemplatePrompt(this.config.templateId) || "";
    }
    if (this.config.customPrompt) {
      if (basePrompt) {
        basePrompt += "\n\n\uCD94\uAC00 \uC9C0\uC2DC\uC0AC\uD56D:\n" + this.config.customPrompt;
      } else {
        basePrompt = this.config.customPrompt + "\n\n## \uBD84\uC11D\uD560 \uB0B4\uC6A9\n{content}";
      }
    }
    const content = this.clipData.content;
    let finalPrompt = basePrompt.replace("{content}", content);
    if (this.config.includeMetadata) {
      const metadata = `
## \uD398\uC774\uC9C0 \uC815\uBCF4
- \uC81C\uBAA9: ${this.clipData.title}
- URL: ${this.clipData.url}
${((_a = this.clipData.metadata) == null ? void 0 : _a.author) ? `- \uC791\uC131\uC790: ${this.clipData.metadata.author}` : ""}
${((_b = this.clipData.metadata) == null ? void 0 : _b.date) ? `- \uC791\uC131\uC77C: ${this.clipData.metadata.date}` : ""}
${((_c = this.clipData.metadata) == null ? void 0 : _c.siteName) ? `- \uC0AC\uC774\uD2B8: ${this.clipData.metadata.siteName}` : ""}
`;
      finalPrompt = metadata + "\n" + finalPrompt;
    }
    const formatInstructions = {
      markdown: "\n\n\uACB0\uACFC\uB294 \uB9C8\uD06C\uB2E4\uC6B4 \uD615\uC2DD\uC73C\uB85C \uC791\uC131\uD574\uC8FC\uC138\uC694.",
      summary: "\n\n\uACB0\uACFC\uB294 \uC9E7\uACE0 \uAC04\uACB0\uD558\uAC8C \uC694\uC57D\uD574\uC8FC\uC138\uC694 (200\uC790 \uC774\uB0B4).",
      bullets: "\n\n\uACB0\uACFC\uB294 \uAE00\uBA38\uB9AC \uAE30\uD638(-)\uB97C \uC0AC\uC6A9\uD55C \uBAA9\uB85D \uD615\uC2DD\uC73C\uB85C \uC791\uC131\uD574\uC8FC\uC138\uC694.",
      qa: "\n\n\uACB0\uACFC\uB294 Q&A \uD615\uC2DD\uC73C\uB85C \uC791\uC131\uD574\uC8FC\uC138\uC694."
    };
    finalPrompt += formatInstructions[this.config.outputFormat] || "";
    if (this.config.language === "ko") {
      finalPrompt += "\n\n\uBC18\uB4DC\uC2DC \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uBCC0\uD574\uC8FC\uC138\uC694.";
    }
    return finalPrompt;
  }
  showError(message) {
    if (!this.resultEl)
      return;
    this.resultEl.empty();
    const errorEl = this.resultEl.createDiv({ cls: "error-display" });
    errorEl.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 150px;
            color: var(--color-red);
        `;
    errorEl.createSpan({ text: "\u274C" }).style.fontSize = "32px";
    errorEl.createSpan({ text: message }).style.cssText = "margin-top: 12px; text-align: center;";
  }
  async saveAsNote() {
    if (!this.resultContent) {
      showWarning("\uC800\uC7A5\uD560 \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      const noteContent = this.buildNoteContent();
      const title = `${this.clipData.title} - AI \uBD84\uC11D`;
      const file = await this.onSave(noteContent, title);
      if (file) {
        showSuccess(`"${file.basename}" \uB178\uD2B8\uAC00 \uC0DD\uC131\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
        this.close();
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : "\uC800\uC7A5 \uC2E4\uD328";
      showError(message);
    }
  }
  buildNoteContent() {
    var _a, _b, _c;
    const now = new Date();
    const timestamp2 = now.toISOString().split("T")[0];
    let content = `---
title: "${this.clipData.title} - AI \uBD84\uC11D"
source: "${this.clipData.url}"
created: ${timestamp2}
type: ai-analysis
provider: ${this.config.provider}
template: ${this.config.templateId || "custom"}
tags:
  - ai-analysis
  - easy-gate
---

# ${this.clipData.title}

> \u{1F517} \uC6D0\uBCF8: [${this.clipData.url}](${this.clipData.url})
> \u{1F916} \uBD84\uC11D: ${AI_PROVIDERS[this.config.provider].displayName}
> \u{1F4C5} \uC0DD\uC131: ${timestamp2}

---

${this.resultContent}

---

## \uC6D0\uBCF8 \uC815\uBCF4

- **\uC81C\uBAA9**: ${this.clipData.title}
- **URL**: ${this.clipData.url}
`;
    if ((_a = this.clipData.metadata) == null ? void 0 : _a.author) {
      content += `- **\uC791\uC131\uC790**: ${this.clipData.metadata.author}
`;
    }
    if ((_b = this.clipData.metadata) == null ? void 0 : _b.date) {
      content += `- **\uC791\uC131\uC77C**: ${this.clipData.metadata.date}
`;
    }
    if ((_c = this.clipData.metadata) == null ? void 0 : _c.siteName) {
      content += `- **\uC0AC\uC774\uD2B8**: ${this.clipData.metadata.siteName}
`;
    }
    return content;
  }
};

// src/modals/MultiSourceAnalysisModal.ts
var import_obsidian13 = require("obsidian");
init_types();
function generateId() {
  return `source-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
function getSourceTypeIcon(type) {
  switch (type) {
    case "web-clip":
      return "\u{1F310}";
    case "obsidian-note":
      return "\u{1F4C4}";
    case "selection":
      return "\u2702\uFE0F";
    case "manual-input":
      return "\u270F\uFE0F";
    default:
      return "\u{1F4DD}";
  }
}
function getSourceTypeLabel(type) {
  switch (type) {
    case "web-clip":
      return "\uC6F9 \uD074\uB9AC\uD551";
    case "obsidian-note":
      return "\uC635\uC2DC\uB514\uC5B8 \uB178\uD2B8";
    case "selection":
      return "\uC120\uD0DD \uD14D\uC2A4\uD2B8";
    case "manual-input":
      return "\uC9C1\uC811 \uC785\uB825";
    default:
      return "\uAE30\uD0C0";
  }
}
var FileSuggestModal = class extends import_obsidian13.FuzzySuggestModal {
  constructor(app, onSelect) {
    super(app);
    this.onSelect = onSelect;
    this.setPlaceholder("\uB178\uD2B8 \uD30C\uC77C\uC744 \uAC80\uC0C9\uD558\uC138\uC694...");
  }
  getItems() {
    return this.app.vault.getMarkdownFiles();
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item) {
    this.onSelect(item);
  }
};
var TextInputModal = class extends import_obsidian13.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.titleInput = "";
    this.contentInput = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("easy-gate-text-input-modal");
    contentEl.createEl("h2", { text: "\u270F\uFE0F \uD14D\uC2A4\uD2B8 \uC9C1\uC811 \uC785\uB825" });
    new import_obsidian13.Setting(contentEl).setName("\uC81C\uBAA9").setDesc("\uC774 \uD14D\uC2A4\uD2B8\uC758 \uC81C\uBAA9\uC744 \uC785\uB825\uD558\uC138\uC694").addText((text) => {
      text.setPlaceholder("\uC608: \uD68C\uC758\uB85D \uC694\uC57D");
      text.onChange((value) => {
        this.titleInput = value;
      });
    });
    const contentSection = contentEl.createDiv({ cls: "content-input-section" });
    contentSection.createEl("label", { text: "\uB0B4\uC6A9" });
    const textArea = contentSection.createEl("textarea", {
      placeholder: "\uBD84\uC11D\uD560 \uD14D\uC2A4\uD2B8\uB97C \uC5EC\uAE30\uC5D0 \uC785\uB825\uD558\uAC70\uB098 \uBD99\uC5EC\uB123\uC73C\uC138\uC694..."
    });
    textArea.style.cssText = `
            width: 100%;
            min-height: 200px;
            margin-top: 8px;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-primary);
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
        `;
    textArea.oninput = (e) => {
      this.contentInput = e.target.value;
    };
    const buttonRow = contentEl.createDiv({ cls: "button-row" });
    buttonRow.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 16px;
        `;
    const cancelBtn = buttonRow.createEl("button", { text: "\uCDE8\uC18C" });
    cancelBtn.onclick = () => this.close();
    const addBtn = buttonRow.createEl("button", { text: "\u2795 \uCD94\uAC00", cls: "mod-cta" });
    addBtn.onclick = () => {
      if (!this.titleInput.trim()) {
        showWarning("\uC81C\uBAA9\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694.");
        return;
      }
      if (!this.contentInput.trim()) {
        showWarning("\uB0B4\uC6A9\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694.");
        return;
      }
      this.onSubmit(this.titleInput.trim(), this.contentInput.trim());
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var MultiSourceAnalysisModal = class extends import_obsidian13.Modal {
  constructor(options) {
    super(options.app);
    this.sources = [];
    this.customPrompt = "";
    this.analysisType = "synthesis";
    this.sourceListContainer = null;
    this.statsContainer = null;
    this.promptTextArea = null;
    this.settings = options.settings;
    this.initialClip = options.initialClip;
    this.onAnalyze = options.onAnalyze;
    this.selectedProvider = options.settings.provider;
    if (options.initialClip) {
      this.addWebClipSource(options.initialClip);
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("easy-gate-multi-source-modal");
    this.modalEl.style.width = "700px";
    this.modalEl.style.maxWidth = "90vw";
    this.renderHeader();
    this.renderSourceManager();
    this.renderAnalysisOptions();
    this.renderCustomPrompt();
    this.renderFooter();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  renderHeader() {
    const { contentEl } = this;
    const header = contentEl.createDiv({ cls: "modal-header" });
    header.createEl("h2", { text: "\u{1F4CA} \uBA40\uD2F0 \uC18C\uC2A4 \uC885\uD569 \uBD84\uC11D" });
    const description = header.createEl("p", { cls: "modal-description" });
    description.style.cssText = `
            font-size: 13px;
            color: var(--text-muted);
            margin-top: 4px;
        `;
    description.textContent = "\uC5EC\uB7EC \uC18C\uC2A4\uB97C \uC218\uD569\uD558\uC5EC AI\uB85C \uC885\uD569 \uBD84\uC11D\uD569\uB2C8\uB2E4. \uC6F9 \uD074\uB9AC\uD551, \uC635\uC2DC\uB514\uC5B8 \uB178\uD2B8, \uC9C1\uC811 \uC785\uB825 \uD14D\uC2A4\uD2B8\uB97C \uCD94\uAC00\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.";
  }
  renderSourceManager() {
    const { contentEl } = this;
    const section = contentEl.createDiv({ cls: "source-manager-section" });
    section.style.cssText = `
            background: var(--background-secondary);
            border-radius: 12px;
            padding: 16px;
            margin: 16px 0;
        `;
    const headerRow = section.createDiv({ cls: "source-header-row" });
    headerRow.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        `;
    headerRow.createEl("h3", { text: "\u{1F4DA} \uBD84\uC11D \uC18C\uC2A4" });
    const addButtonsRow = headerRow.createDiv({ cls: "add-buttons" });
    addButtonsRow.style.cssText = `
            display: flex;
            gap: 8px;
        `;
    const addNoteBtn = addButtonsRow.createEl("button", {
      text: "\u{1F4C4} \uB178\uD2B8 \uCD94\uAC00",
      cls: "add-source-btn"
    });
    addNoteBtn.style.cssText = this.getButtonStyle();
    addNoteBtn.onclick = () => this.openFilePicker();
    const addTextBtn = addButtonsRow.createEl("button", {
      text: "\u270F\uFE0F \uD14D\uC2A4\uD2B8 \uC785\uB825",
      cls: "add-source-btn"
    });
    addTextBtn.style.cssText = this.getButtonStyle();
    addTextBtn.onclick = () => this.openTextInputModal();
    this.sourceListContainer = section.createDiv({ cls: "source-list" });
    this.sourceListContainer.style.cssText = `
            max-height: 250px;
            overflow-y: auto;
            border-radius: 8px;
        `;
    this.statsContainer = section.createDiv({ cls: "source-stats" });
    this.statsContainer.style.cssText = `
            display: flex;
            gap: 16px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--background-modifier-border);
            font-size: 12px;
            color: var(--text-muted);
        `;
    this.renderSourceList();
    this.updateStats();
  }
  renderSourceList() {
    if (!this.sourceListContainer)
      return;
    this.sourceListContainer.empty();
    if (this.sources.length === 0) {
      const emptyState = this.sourceListContainer.createDiv({ cls: "empty-state" });
      emptyState.style.cssText = `
                text-align: center;
                padding: 32px;
                color: var(--text-muted);
            `;
      emptyState.createEl("p", { text: "\u{1F4ED} \uBD84\uC11D\uD560 \uC18C\uC2A4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4." });
      emptyState.createEl("p", {
        text: "\uC704 \uBC84\uD2BC\uC73C\uB85C \uC635\uC2DC\uB514\uC5B8 \uB178\uD2B8\uB098 \uD14D\uC2A4\uD2B8\uB97C \uCD94\uAC00\uD558\uC138\uC694.",
        cls: "empty-hint"
      }).style.fontSize = "12px";
      return;
    }
    this.sources.forEach((source, index) => {
      const item = this.sourceListContainer.createDiv({ cls: "source-item" });
      item.style.cssText = `
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 12px;
                background: var(--background-primary);
                border-radius: 8px;
                margin-bottom: 8px;
                border: 1px solid var(--background-modifier-border);
            `;
      const icon = item.createSpan({ cls: "source-icon" });
      icon.textContent = getSourceTypeIcon(source.type);
      icon.style.fontSize = "18px";
      const info = item.createDiv({ cls: "source-info" });
      info.style.cssText = `
                flex: 1;
                min-width: 0;
            `;
      const title = info.createDiv({ cls: "source-title" });
      title.style.cssText = `
                font-weight: 500;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            `;
      title.textContent = source.title;
      const meta = info.createDiv({ cls: "source-meta" });
      meta.style.cssText = `
                font-size: 11px;
                color: var(--text-muted);
                display: flex;
                gap: 8px;
                margin-top: 2px;
            `;
      meta.createSpan({ text: getSourceTypeLabel(source.type) });
      meta.createSpan({ text: `${source.metadata.charCount.toLocaleString()}\uC790` });
      if (source.metadata.url) {
        const urlSpan = meta.createSpan();
        urlSpan.createEl("a", {
          text: new URL(source.metadata.url).hostname,
          href: source.metadata.url
        }).style.color = "var(--text-accent)";
      }
      if (source.metadata.filePath) {
        meta.createSpan({ text: source.metadata.filePath });
      }
      const deleteBtn = item.createEl("button", { text: "\u{1F5D1}\uFE0F" });
      deleteBtn.style.cssText = `
                padding: 4px 8px;
                border: none;
                background: transparent;
                cursor: pointer;
                opacity: 0.6;
                transition: opacity 0.2s;
            `;
      deleteBtn.onmouseenter = () => deleteBtn.style.opacity = "1";
      deleteBtn.onmouseleave = () => deleteBtn.style.opacity = "0.6";
      deleteBtn.onclick = () => this.removeSource(index);
    });
  }
  renderAnalysisOptions() {
    const { contentEl } = this;
    const section = contentEl.createDiv({ cls: "analysis-options-section" });
    section.style.marginBottom = "16px";
    section.createEl("h3", { text: "\u2699\uFE0F \uBD84\uC11D \uC635\uC158" });
    new import_obsidian13.Setting(section).setName("\uBD84\uC11D \uC720\uD615").setDesc("\uC18C\uC2A4\uB4E4\uC744 \uC5B4\uB5BB\uAC8C \uBD84\uC11D\uD560\uC9C0 \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => {
      dropdown.addOption("synthesis", "\u{1F504} \uC885\uD569 \uBD84\uC11D - \uBAA8\uB4E0 \uC18C\uC2A4\uB97C \uD1B5\uD569\uD558\uC5EC \uC694\uC57D").addOption("comparison", "\u2696\uFE0F \uBE44\uAD50 \uBD84\uC11D - \uC18C\uC2A4 \uAC04 \uCC28\uC774\uC810/\uACF5\uD1B5\uC810 \uBD84\uC11D").addOption("summary", "\u{1F4DD} \uAC1C\uBCC4 \uC694\uC57D - \uAC01 \uC18C\uC2A4\uB97C \uC694\uC57D \uD6C4 \uC885\uD569").addOption("custom", "\u270F\uFE0F \uCEE4\uC2A4\uD140 - \uD504\uB86C\uD504\uD2B8\uB9CC \uC0AC\uC6A9").setValue(this.analysisType).onChange((value) => {
        this.analysisType = value;
      });
    });
    const hasApiKey = (providerId) => {
      const key = this.settings.apiKeys[providerId];
      return !!key && key.trim().length > 0;
    };
    new import_obsidian13.Setting(section).setName("AI \uC81C\uACF5\uC790").setDesc("\uBD84\uC11D\uC5D0 \uC0AC\uC6A9\uD560 AI\uB97C \uC120\uD0DD\uD558\uC138\uC694").addDropdown((dropdown) => {
      Object.values(AI_PROVIDERS).forEach((provider) => {
        const configured = hasApiKey(provider.id);
        dropdown.addOption(provider.id, `${provider.displayName} ${configured ? "\u2705" : "\u26A0\uFE0F"}`);
      });
      dropdown.setValue(this.selectedProvider);
      dropdown.onChange((value) => {
        this.selectedProvider = value;
      });
    });
  }
  renderCustomPrompt() {
    const { contentEl } = this;
    const section = contentEl.createDiv({ cls: "custom-prompt-section" });
    section.createEl("h3", { text: "\u{1F4AC} \uBD84\uC11D \uC9C0\uC2DC\uC0AC\uD56D (\uC120\uD0DD)" });
    const guide = section.createEl("p", { cls: "prompt-guide" });
    guide.style.cssText = `
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 8px;
        `;
    guide.textContent = "AI\uC5D0\uAC8C \uD2B9\uBCC4\uD55C \uBD84\uC11D \uBC29\uD5A5\uC774\uB098 \uC694\uCCAD\uC0AC\uD56D\uC744 \uC785\uB825\uD558\uC138\uC694. \uBE44\uC6CC\uB450\uBA74 \uAE30\uBCF8 \uBD84\uC11D\uC774 \uC218\uD589\uB429\uB2C8\uB2E4.";
    new import_obsidian13.Setting(section).setClass("prompt-textarea-setting").addTextArea((text) => {
      this.promptTextArea = text;
      text.setPlaceholder("\uC608\uC2DC:\n- \uC774 \uC790\uB8CC\uB4E4\uC5D0\uC11C AI \uAD50\uC721\uC758 \uD575\uC2EC \uD2B8\uB80C\uB4DC\uB97C \uC815\uB9AC\uD574\uC918\n- \uAC01 \uC18C\uC2A4\uC758 \uC8FC\uC7A5\uC744 \uBE44\uAD50\uD558\uACE0 \uACF5\uD1B5\uC810\uACFC \uCC28\uC774\uC810\uC744 \uBD84\uC11D\uD574\uC918\n- \uC2E4\uC81C \uAD50\uC721 \uD604\uC7A5\uC5D0 \uC801\uC6A9\uD560 \uC218 \uC788\uB294 \uC778\uC0AC\uC774\uD2B8\uB97C \uCD94\uCD9C\uD574\uC918");
      text.inputEl.style.cssText = `
                    width: 100%;
                    min-height: 100px;
                    resize: vertical;
                    font-size: 13px;
                    line-height: 1.5;
                `;
      text.onChange((value) => {
        this.customPrompt = value;
      });
    });
  }
  renderFooter() {
    const { contentEl } = this;
    const footer = contentEl.createDiv({ cls: "modal-footer" });
    footer.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--background-modifier-border);
        `;
    const helpText = footer.createSpan({ cls: "footer-help" });
    helpText.style.cssText = `
            font-size: 12px;
            color: var(--text-muted);
        `;
    helpText.textContent = "\u{1F4A1} \uC5EC\uB7EC \uC18C\uC2A4\uB97C \uC885\uD569\uD558\uBA74 \uB354 \uD48D\uBD80\uD55C \uC778\uC0AC\uC774\uD2B8\uB97C \uC5BB\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4.";
    const buttonGroup = footer.createDiv({ cls: "button-group" });
    buttonGroup.style.cssText = `
            display: flex;
            gap: 10px;
        `;
    const cancelBtn = buttonGroup.createEl("button", { text: "\uCDE8\uC18C" });
    cancelBtn.onclick = () => this.close();
    const analyzeBtn = buttonGroup.createEl("button", {
      text: "\u{1F4CA} \uC885\uD569 \uBD84\uC11D \uC2DC\uC791",
      cls: "mod-cta"
    });
    analyzeBtn.style.cssText = `
            padding: 10px 20px;
            font-weight: 500;
        `;
    analyzeBtn.onclick = () => this.startAnalysis();
  }
  addWebClipSource(clipData) {
    const source = {
      id: generateId(),
      type: "web-clip",
      title: clipData.title || "\uC6F9 \uD074\uB9AC\uD551",
      content: clipData.content,
      metadata: {
        url: clipData.url,
        siteName: clipData.metadata.siteName,
        author: clipData.metadata.author,
        publishedDate: clipData.metadata.date,
        charCount: clipData.content.length,
        wordCount: clipData.content.split(/\s+/).filter((w) => w).length
      },
      addedAt: new Date().toISOString()
    };
    this.sources.push(source);
  }
  async addObsidianNote(file) {
    var _a;
    try {
      const content = await this.app.vault.read(file);
      const cache = this.app.metadataCache.getFileCache(file);
      const source = {
        id: generateId(),
        type: "obsidian-note",
        title: file.basename,
        content,
        metadata: {
          filePath: file.path,
          tags: ((_a = cache == null ? void 0 : cache.tags) == null ? void 0 : _a.map((t) => t.tag)) || [],
          charCount: content.length,
          wordCount: content.split(/\s+/).filter((w) => w).length
        },
        addedAt: new Date().toISOString()
      };
      this.sources.push(source);
      this.renderSourceList();
      this.updateStats();
      showSuccess(`\uB178\uD2B8 \uCD94\uAC00\uB428: ${file.basename}`);
    } catch (error) {
      showError(`\uB178\uD2B8\uB97C \uC77D\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4: ${file.path}`);
    }
  }
  addManualInput(title, content) {
    const source = {
      id: generateId(),
      type: "manual-input",
      title,
      content,
      metadata: {
        charCount: content.length,
        wordCount: content.split(/\s+/).filter((w) => w).length
      },
      addedAt: new Date().toISOString()
    };
    this.sources.push(source);
    this.renderSourceList();
    this.updateStats();
    showSuccess(`\uD14D\uC2A4\uD2B8 \uCD94\uAC00\uB428: ${title}`);
  }
  removeSource(index) {
    const removed = this.sources.splice(index, 1)[0];
    this.renderSourceList();
    this.updateStats();
    showSuccess(`\uC18C\uC2A4 \uC0AD\uC81C\uB428: ${removed.title}`);
  }
  openFilePicker() {
    const modal = new FileSuggestModal(this.app, async (file) => {
      await this.addObsidianNote(file);
    });
    modal.open();
  }
  openTextInputModal() {
    const modal = new TextInputModal(this.app, (title, content) => {
      this.addManualInput(title, content);
    });
    modal.open();
  }
  updateStats() {
    if (!this.statsContainer)
      return;
    this.statsContainer.empty();
    const totalSources = this.sources.length;
    const totalChars = this.sources.reduce((sum, s) => sum + s.metadata.charCount, 0);
    const totalWords = this.sources.reduce((sum, s) => sum + s.metadata.wordCount, 0);
    const estimatedTokens = Math.ceil(totalChars / 4);
    this.statsContainer.createSpan({ text: `\u{1F4DA} ${totalSources}\uAC1C \uC18C\uC2A4` });
    this.statsContainer.createSpan({ text: `\u{1F4CA} ${totalChars.toLocaleString()}\uC790` });
    this.statsContainer.createSpan({ text: `\u{1F4DD} ${totalWords.toLocaleString()} \uB2E8\uC5B4` });
    this.statsContainer.createSpan({ text: `\u{1F3AB} ~${estimatedTokens.toLocaleString()} \uD1A0\uD070` });
    if (totalSources === 0) {
      const warningSpan = this.statsContainer.createSpan({ text: "\u26A0\uFE0F \uC18C\uC2A4\uB97C \uCD94\uAC00\uD558\uC138\uC694" });
      warningSpan.style.color = "var(--text-warning)";
    }
  }
  getButtonStyle() {
    return `
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
            border: 1px solid var(--background-modifier-border);
            background: var(--background-primary);
            cursor: pointer;
            transition: all 0.2s;
        `;
  }
  async startAnalysis() {
    if (this.sources.length === 0) {
      showWarning("\uBD84\uC11D\uD560 \uC18C\uC2A4\uB97C \uD558\uB098 \uC774\uC0C1 \uCD94\uAC00\uD574\uC8FC\uC138\uC694.");
      return;
    }
    const aiService = getAIService();
    if (!(aiService == null ? void 0 : aiService.isProviderConfigured(this.selectedProvider))) {
      showWarning(`${AI_PROVIDERS[this.selectedProvider].displayName} API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.`);
      return;
    }
    const request = {
      sources: [...this.sources],
      customPrompt: this.customPrompt.trim(),
      analysisType: this.analysisType,
      outputFormat: "markdown",
      includeSourceReferences: true,
      language: this.settings.defaultLanguage || "\uD55C\uAD6D\uC5B4"
    };
    this.close();
    await this.onAnalyze(request);
  }
};

// src/GateView.ts
var GateView = class extends import_obsidian14.ItemView {
  constructor(leaf, options, plugin) {
    super(leaf);
    this.useIframe = false;
    this.isFrameReady = false;
    this.insertMode = "cursor";
    this.clipDropdown = null;
    this.aiDropdown = null;
    this.clipService = null;
    this.navigation = false;
    this.options = options;
    this.plugin = plugin;
    this.useIframe = import_obsidian15.Platform.isMobileApp;
    this.frameReadyCallbacks = [];
    this.currentGateState = { id: options.id, url: options.url, title: options.title };
    if (!this.useIframe) {
      this.clipService = getClipService() || initializeClipService({
        vault: this.app.vault,
        settings: this.plugin.settings.clipping
      });
    }
  }
  addActions() {
    this.addAction("refresh-ccw", "Reload", () => {
      var _a;
      if (this.frame instanceof HTMLIFrameElement) {
        (_a = this.frame.contentWindow) == null ? void 0 : _a.location.reload();
      } else {
        this.frame.reload();
      }
    });
    this.addAction("home", "Home page", () => {
      var _a, _b;
      this.navigateTo((_b = (_a = this.options) == null ? void 0 : _a.url) != null ? _b : "about:blank");
    });
  }
  isWebviewFrame() {
    return this.frame instanceof HTMLIFrameElement;
  }
  onload() {
    super.onload();
    this.addActions();
    this.contentEl.empty();
    this.contentEl.addClass("open-gate-view");
    if (!this.useIframe) {
      this.initializeDropdowns();
    }
    this.drawTopBar();
    this.frameDoc = this.contentEl.doc;
    this.createFrame();
  }
  initializeDropdowns() {
    this.clipDropdown = new ClipDropdown({
      app: this.app,
      settings: this.plugin.settings.clipping,
      onClipPage: () => this.handleClipPage(),
      onClipSelection: () => this.handleClipSelection(),
      onClipToNote: (file) => this.handleClipToNote(file),
      onOpenSettings: () => this.openClipSettings()
    });
    this.aiDropdown = new AIDropdown({
      app: this.app,
      settings: this.plugin.settings.ai,
      savedPrompts: this.plugin.settings.savedPrompts || [],
      onAISummary: () => this.handleAISummary(),
      onAIWithTemplate: (templateId) => this.handleAIWithTemplate(templateId),
      onAIWithPrompt: (prompt2) => this.handleAIWithPrompt(prompt2),
      onAISelection: () => this.handleAISelection(),
      onOpenAnalysisModal: (templateId) => this.openAnalysisModal(templateId),
      onOpenMultiSourceModal: () => this.openMultiSourceModal(),
      onOpenSettings: () => this.openAISettings()
    });
  }
  async handleClipPage() {
    if (this.useIframe || !this.clipService) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC \uD074\uB9AC\uD551\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const loading = showLoading("\uD398\uC774\uC9C0 \uD074\uB9AC\uD551 \uC911...");
    try {
      const result = await this.clipService.clipPage(this.frame, this.currentGateState.id);
      loading.hide();
      if (result.success && result.note) {
        showSuccess(`\uD074\uB9AC\uD551 \uC644\uB8CC: ${result.note.path}`);
      } else {
        showError(result.error || "\uD074\uB9AC\uD551 \uC2E4\uD328");
      }
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`\uD074\uB9AC\uD551 \uC624\uB958: ${errorMessage}`);
    }
  }
  async handleClipSelection() {
    if (this.useIframe || !this.clipService) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC \uD074\uB9AC\uD551\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const loading = showLoading("\uC120\uD0DD \uD14D\uC2A4\uD2B8 \uD074\uB9AC\uD551 \uC911...");
    try {
      const result = await this.clipService.clipSelection(this.frame, this.currentGateState.id);
      loading.hide();
      if (result.success && result.note) {
        showSuccess(`\uD074\uB9AC\uD551 \uC644\uB8CC: ${result.note.path}`);
      } else {
        showError(result.error || "\uC120\uD0DD\uB41C \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      }
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`\uD074\uB9AC\uD551 \uC624\uB958: ${errorMessage}`);
    }
  }
  async handleClipToNote(targetFile) {
    if (this.useIframe || !this.clipService) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC \uD074\uB9AC\uD551\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const loading = showLoading(`${targetFile.basename}\uC5D0 \uCD94\uAC00 \uC911...`);
    try {
      const result = await this.clipService.clipToNote(this.frame, this.currentGateState.id, targetFile);
      loading.hide();
      if (result.success) {
        showSuccess(`\uD074\uB9AC\uD551\uC774 ${targetFile.basename}\uC5D0 \uCD94\uAC00\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
      } else {
        showError(result.error || "\uD074\uB9AC\uD551 \uCD94\uAC00 \uC2E4\uD328");
      }
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`\uD074\uB9AC\uD551 \uC624\uB958: ${errorMessage}`);
    }
  }
  openClipSettings() {
    var _a, _b, _c;
    (_a = this.app.setting) == null ? void 0 : _a.open();
    (_c = (_b = this.app.setting) == null ? void 0 : _b.openTabById) == null ? void 0 : _c.call(_b, this.plugin.manifest.id);
  }
  async handleAISummary() {
    if (this.useIframe) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC AI \uAE30\uB2A5\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const aiService = getAIService();
    if (!aiService) {
      showError("AI \uC11C\uBE44\uC2A4\uAC00 \uCD08\uAE30\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      return;
    }
    if (!aiService.isProviderConfigured(this.plugin.settings.ai.provider)) {
      showError("API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    const loading = showLoading("AI \uC694\uC57D \uC0DD\uC131 \uC911...");
    try {
      const { ContentExtractor: ContentExtractor2 } = await Promise.resolve().then(() => (init_clipping(), clipping_exports));
      const content = await ContentExtractor2.extractPageContent(this.frame);
      if (!content) {
        loading.hide();
        showError("\uD398\uC774\uC9C0 \uCF58\uD150\uCE20\uB97C \uCD94\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const response = await aiService.summarizeContent(content.textContent, this.plugin.settings.ai.defaultLanguage);
      loading.hide();
      if (response.success) {
        const timestamp2 = new Date().toISOString().split("T")[0];
        const currentUrl = await ContentExtractor2.getCurrentUrl(this.frame);
        const baseFileName = `AI \uC694\uC57D - ${content.title || "Untitled"} - ${timestamp2}.md`;
        const fileName = await this.getUniqueFileName(baseFileName);
        const noteContent = `---
title: "${content.title || "AI \uC694\uC57D"}"
source: "${currentUrl}"
created: ${timestamp2}
type: ai-summary
provider: ${this.plugin.settings.ai.provider}
site: "${content.siteName || ""}"
tags:
  - ai-summary
  - easy-gate
---

# ${content.title || "AI \uC694\uC57D"}

> \u{1F517} \uC6D0\uBCF8: [${currentUrl}](${currentUrl})
> \u{1F916} \uBD84\uC11D: ${this.plugin.settings.ai.provider}
> \u{1F4C5} \uC0DD\uC131: ${timestamp2}

---

${response.content}

---

## \uC6D0\uBCF8 \uC815\uBCF4

- **\uC81C\uBAA9**: ${content.title || "Untitled"}
- **URL**: ${currentUrl}
- **\uC0AC\uC774\uD2B8**: ${content.siteName || "Unknown"}
`;
        const file = await this.app.vault.create(fileName, noteContent);
        await this.app.workspace.getLeaf("tab").openFile(file);
        showSuccess("AI \uC694\uC57D\uC774 \uC0DD\uC131\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      } else {
        showError(response.error || "AI \uC694\uC57D \uC0DD\uC131 \uC2E4\uD328");
      }
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`AI \uC624\uB958: ${errorMessage}`);
    }
  }
  async handleAIWithTemplate(templateId) {
    if (this.useIframe) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC AI \uAE30\uB2A5\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const aiService = getAIService();
    if (!aiService || !aiService.isProviderConfigured(this.plugin.settings.ai.provider)) {
      showError("API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const loading = showLoading("\uCF58\uD150\uCE20 \uCD94\uCD9C \uC911...");
    try {
      const content = await ContentExtractor.extractPageContent(this.frame);
      const url = await ContentExtractor.getCurrentUrl(this.frame);
      loading.hide();
      if (!content) {
        showError("\uD398\uC774\uC9C0 \uCF58\uD150\uCE20\uB97C \uCD94\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const clipData = {
        id: `template-${Date.now()}`,
        url,
        title: content.title || "Untitled",
        content: content.textContent,
        metadata: {
          siteName: content.siteName
        },
        clippedAt: new Date().toISOString(),
        gateId: this.currentGateState.id
      };
      const config = {
        templateId,
        customPrompt: null,
        provider: this.plugin.settings.ai.provider,
        includeMetadata: true,
        outputFormat: "markdown",
        language: this.plugin.settings.ai.defaultLanguage || "ko"
      };
      await this.runAnalysis(clipData, config);
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`\uD15C\uD50C\uB9BF \uCC98\uB9AC \uC624\uB958: ${errorMessage}`);
    }
  }
  async handleAIWithPrompt(prompt2) {
    if (this.useIframe) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC AI \uAE30\uB2A5\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const aiService = getAIService();
    if (!aiService) {
      showError("AI \uC11C\uBE44\uC2A4\uAC00 \uCD08\uAE30\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const loading = showLoading("AI \uCC98\uB9AC \uC911...");
    try {
      const { ContentExtractor: ContentExtractor2 } = await Promise.resolve().then(() => (init_clipping(), clipping_exports));
      const content = await ContentExtractor2.extractPageContent(this.frame);
      if (!content) {
        loading.hide();
        showError("\uD398\uC774\uC9C0 \uCF58\uD150\uCE20\uB97C \uCD94\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const response = await aiService.simpleGenerate(`${prompt2}

\uCF58\uD150\uCE20:
${content.textContent}`, `\uB2F9\uC2E0\uC740 \uC6F9 \uCF58\uD150\uCE20 \uBD84\uC11D \uC804\uBB38\uAC00\uC785\uB2C8\uB2E4. \uD56D\uC0C1 ${this.plugin.settings.ai.defaultLanguage}\uB85C \uC751\uB2F5\uD558\uC138\uC694.`);
      loading.hide();
      if (response.success) {
        const timestamp2 = new Date().toISOString().split("T")[0];
        const currentUrl = await ContentExtractor2.getCurrentUrl(this.frame);
        const baseFileName = `AI \uBD84\uC11D - ${content.title || "Untitled"} - ${timestamp2}.md`;
        const fileName = await this.getUniqueFileName(baseFileName);
        const noteContent = `---
title: "${content.title || "AI \uBD84\uC11D"}"
source: "${currentUrl}"
created: ${timestamp2}
type: ai-analysis
provider: ${this.plugin.settings.ai.provider}
site: "${content.siteName || ""}"
prompt: "${prompt2.replace(/"/g, '\\"').substring(0, 100)}..."
tags:
  - ai-analysis
  - easy-gate
  - custom-prompt
---

# ${content.title || "AI \uBD84\uC11D"}

> \u{1F517} \uC6D0\uBCF8: [${currentUrl}](${currentUrl})
> \u{1F916} \uBD84\uC11D: ${this.plugin.settings.ai.provider}
> \u{1F4C5} \uC0DD\uC131: ${timestamp2}

---

**\uD504\uB86C\uD504\uD2B8:** ${prompt2}

---

${response.content}

---

## \uC6D0\uBCF8 \uC815\uBCF4

- **\uC81C\uBAA9**: ${content.title || "Untitled"}
- **URL**: ${currentUrl}
- **\uC0AC\uC774\uD2B8**: ${content.siteName || "Unknown"}
`;
        const file = await this.app.vault.create(fileName, noteContent);
        await this.app.workspace.getLeaf("tab").openFile(file);
        showSuccess("AI \uBD84\uC11D\uC774 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      } else {
        showError(response.error || "AI \uCC98\uB9AC \uC2E4\uD328");
      }
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`AI \uC624\uB958: ${errorMessage}`);
    }
  }
  async handleAISelection() {
    if (this.useIframe) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC AI \uAE30\uB2A5\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const aiService = getAIService();
    if (!aiService) {
      showError("AI \uC11C\uBE44\uC2A4\uAC00 \uCD08\uAE30\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      return;
    }
    try {
      const { ContentExtractor: ContentExtractor2 } = await Promise.resolve().then(() => (init_clipping(), clipping_exports));
      const selection = await ContentExtractor2.extractSelection(this.frame);
      if (!selection || !selection.hasSelection) {
        showError("\uC120\uD0DD\uB41C \uD14D\uC2A4\uD2B8\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const loading = showLoading("\uC120\uD0DD \uD14D\uC2A4\uD2B8 AI \uCC98\uB9AC \uC911...");
      const response = await aiService.summarizeContent(selection.text, this.plugin.settings.ai.defaultLanguage);
      loading.hide();
      if (response.success) {
        new import_obsidian14.Notice(`AI \uBD84\uC11D \uACB0\uACFC:
${response.content.substring(0, 200)}...`, 1e4);
      } else {
        showError(response.error || "AI \uCC98\uB9AC \uC2E4\uD328");
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`AI \uC624\uB958: ${errorMessage}`);
    }
  }
  async openAnalysisModal(templateId) {
    if (this.useIframe) {
      showError("Desktop \uD658\uACBD\uC5D0\uC11C\uB9CC \uBD84\uC11D \uAE30\uB2A5\uC774 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
      return;
    }
    const loading = showLoading("\uCF58\uD150\uCE20 \uCD94\uCD9C \uC911...");
    try {
      let selectedText = "";
      try {
        const selection = await ContentExtractor.extractSelection(this.frame);
        if (selection && selection.hasSelection && selection.text) {
          selectedText = selection.text;
        }
      } catch (e) {
      }
      const content = await ContentExtractor.extractPageContent(this.frame);
      const url = await ContentExtractor.getCurrentUrl(this.frame);
      loading.hide();
      if (!content) {
        showError("\uD398\uC774\uC9C0 \uCF58\uD150\uCE20\uB97C \uCD94\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const clipData = {
        id: `analysis-${Date.now()}`,
        url,
        title: content.title || "Untitled",
        content: content.textContent,
        metadata: {
          siteName: content.siteName
        },
        clippedAt: new Date().toISOString(),
        gateId: this.currentGateState.id
      };
      const modal = new AnalysisModal({
        app: this.app,
        settings: this.plugin.settings.ai,
        savedPrompts: this.plugin.settings.savedPrompts || [],
        clipData,
        initialText: selectedText,
        initialTemplateId: templateId,
        onAnalyze: async (config, editedContent) => {
          const updatedClipData = { ...clipData, content: editedContent };
          await this.runAnalysis(updatedClipData, config);
        },
        onSavePrompt: (prompt2) => {
          this.savePromptToSettings(prompt2);
        }
      });
      modal.open();
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`\uBD84\uC11D \uBAA8\uB2EC \uC624\uB958: ${errorMessage}`);
    }
  }
  async runAnalysis(clipData, config) {
    const processModal = new ProcessModal({
      app: this.app,
      clipData,
      config,
      onSave: async (content, title) => {
        return await this.saveAnalysisResult(content, title);
      }
    });
    processModal.open();
  }
  async saveAnalysisResult(content, title) {
    try {
      const aiSettings = this.plugin.settings.ai;
      const folderPath = aiSettings.aiNotesFolder || "AI-Notes";
      const sanitizedTitle = title.replace(/[\\/:*?"<>|]/g, "-");
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder) {
        await this.app.vault.createFolder(folderPath);
      }
      const filePath = await this.getUniqueFilePath(folderPath, sanitizedTitle);
      const file = await this.app.vault.create(filePath, content);
      if (aiSettings.autoOpenNote !== false) {
        await this.app.workspace.getLeaf("tab").openFile(file);
      }
      showSuccess(`\uB178\uD2B8 \uC800\uC7A5 \uC644\uB8CC: ${filePath}`);
      return file;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "\uC800\uC7A5 \uC2E4\uD328";
      showError(errorMessage);
      return null;
    }
  }
  async getUniqueFilePath(folderPath, baseName) {
    const extension = ".md";
    let filePath = `${folderPath}/${baseName}${extension}`;
    if (!this.plugin.app.vault.getAbstractFileByPath(filePath)) {
      return filePath;
    }
    let counter = 1;
    filePath = `${folderPath}/${baseName} (${counter})${extension}`;
    while (this.plugin.app.vault.getAbstractFileByPath(filePath)) {
      counter++;
      filePath = `${folderPath}/${baseName} (${counter})${extension}`;
      if (counter > 100) {
        const timestamp2 = Date.now();
        filePath = `${folderPath}/${baseName} - ${timestamp2}${extension}`;
        break;
      }
    }
    return filePath;
  }
  async openMultiSourceModal() {
    const loading = showLoading("\uBA40\uD2F0 \uC18C\uC2A4 \uBD84\uC11D \uC900\uBE44 \uC911...");
    try {
      let initialClip;
      if (!this.useIframe) {
        try {
          const content = await ContentExtractor.extractPageContent(this.frame);
          const url = await ContentExtractor.getCurrentUrl(this.frame);
          if (content && content.textContent && content.textContent.trim().length > 0) {
            initialClip = {
              id: `multi-source-${Date.now()}`,
              url,
              title: content.title || this.options.title || "Untitled",
              content: content.textContent,
              metadata: {
                siteName: content.siteName || this.extractSiteName(url)
              },
              clippedAt: new Date().toISOString(),
              gateId: this.currentGateState.id
            };
          }
        } catch (e) {
          console.log("[MultiSource] \uD604\uC7AC \uD398\uC774\uC9C0 \uCF58\uD150\uCE20 \uCD94\uCD9C \uC2E4\uD328:", e);
        }
      }
      loading.hide();
      const modal = new MultiSourceAnalysisModal({
        app: this.app,
        settings: this.plugin.settings.ai,
        initialClip,
        onAnalyze: async (request) => {
          await this.runMultiSourceAnalysis(request);
        }
      });
      modal.open();
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uC54C \uC218 \uC5C6\uB294 \uC624\uB958";
      showError(`\uBA40\uD2F0 \uC18C\uC2A4 \uBD84\uC11D \uC624\uB958: ${errorMessage}`);
    }
  }
  extractSiteName(url) {
    try {
      const urlObj = new URL(url);
      let hostname = urlObj.hostname.replace(/^www\./, "");
      const siteNames = {
        "youtube.com": "YouTube",
        "github.com": "GitHub",
        "twitter.com": "Twitter",
        "x.com": "X (Twitter)",
        "reddit.com": "Reddit",
        "medium.com": "Medium",
        "notion.so": "Notion",
        "naver.com": "Naver",
        "tistory.com": "Tistory",
        "velog.io": "Velog",
        "brunch.co.kr": "Brunch",
        "google.com": "Google",
        "docs.google.com": "Google Docs",
        "wikipedia.org": "Wikipedia"
      };
      return siteNames[hostname] || hostname;
    } catch (e) {
      return "Unknown";
    }
  }
  async runMultiSourceAnalysis(request) {
    const loading = showLoading("\uBA40\uD2F0 \uC18C\uC2A4 \uBD84\uC11D \uC911...");
    try {
      const aiSettings = this.plugin.settings.ai;
      const provider = aiSettings.provider;
      const apiKey = aiSettings.apiKeys[provider];
      if (!apiKey) {
        throw new Error(`${provider} API \uD0A4\uAC00 \uC124\uC815\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.`);
      }
      const sourcesContext = request.sources.map((source, index) => {
        const sourceInfo = `[\uC18C\uC2A4 ${index + 1}] ${source.title}
\uD0C0\uC785: ${source.type === "web-clip" ? "\uC6F9 \uD074\uB9AC\uD551" : source.type === "obsidian-note" ? "\uC635\uC2DC\uB514\uC5B8 \uB178\uD2B8" : source.type === "selection" ? "\uC120\uD0DD \uD14D\uC2A4\uD2B8" : "\uC9C1\uC811 \uC785\uB825"}
${source.metadata.url ? `URL: ${source.metadata.url}` : ""}
${source.metadata.filePath ? `\uD30C\uC77C: ${source.metadata.filePath}` : ""}
\uAE00\uC790 \uC218: ${source.metadata.charCount}\uC790

\uB0B4\uC6A9:
${source.content}
`;
        return sourceInfo;
      }).join("\n---\n\n");
      const analysisTypePrompts = {
        "synthesis": "\uC5EC\uB7EC \uC18C\uC2A4\uC758 \uC815\uBCF4\uB97C \uC885\uD569\uD558\uC5EC \uD1B5\uD569\uB41C \uAD00\uC810\uC744 \uC81C\uC2DC\uD574\uC8FC\uC138\uC694. \uACF5\uD1B5\uC810, \uD575\uC2EC \uC778\uC0AC\uC774\uD2B8, \uADF8\uB9AC\uACE0 \uC0C8\uB85C\uC6B4 \uD1B5\uCC30\uC744 \uB3C4\uCD9C\uD574\uC8FC\uC138\uC694.",
        "comparison": "\uAC01 \uC18C\uC2A4\uC758 \uAD00\uC810\uC744 \uBE44\uAD50 \uBD84\uC11D\uD574\uC8FC\uC138\uC694. \uC720\uC0AC\uC810\uACFC \uCC28\uC774\uC810, \uAC01\uAC01\uC758 \uAC15\uC810\uACFC \uC57D\uC810\uC744 \uBD84\uC11D\uD574\uC8FC\uC138\uC694.",
        "summary": "\uBAA8\uB4E0 \uC18C\uC2A4\uC758 \uD575\uC2EC \uB0B4\uC6A9\uC744 \uAC04\uACB0\uD558\uAC8C \uC694\uC57D\uD574\uC8FC\uC138\uC694. \uC8FC\uC694 \uD3EC\uC778\uD2B8\uC640 \uACB0\uB860\uC744 \uC815\uB9AC\uD574\uC8FC\uC138\uC694.",
        "custom": ""
      };
      const basePrompt = analysisTypePrompts[request.analysisType] || "";
      const fullPrompt = request.customPrompt ? `${request.customPrompt}

${basePrompt}` : basePrompt;
      const systemPrompt = `\uB2F9\uC2E0\uC740 \uB2E4\uC911 \uC18C\uC2A4 \uBD84\uC11D \uC804\uBB38\uAC00\uC785\uB2C8\uB2E4. \uC5EC\uB7EC \uCD9C\uCC98\uC758 \uC815\uBCF4\uB97C \uBD84\uC11D\uD558\uACE0 \uD1B5\uD569\uD558\uB294 \uC5ED\uD560\uC744 \uD569\uB2C8\uB2E4.

\uBD84\uC11D \uC2DC \uB2E4\uC74C \uC0AC\uD56D\uC744 \uACE0\uB824\uD558\uC138\uC694:
1. \uAC01 \uC18C\uC2A4\uC758 \uC2E0\uB8B0\uC131\uACFC \uAD00\uC810\uC744 \uD3C9\uAC00
2. \uC18C\uC2A4 \uAC04\uC758 \uAD00\uACC4\uC640 \uC0C1\uD638 \uBCF4\uC644\uC131 \uD30C\uC545
3. \uD575\uC2EC \uC778\uC0AC\uC774\uD2B8\uC640 \uD328\uD134 \uB3C4\uCD9C
4. \uBA85\uD655\uD558\uACE0 \uAD6C\uC870\uD654\uB41C \uBD84\uC11D \uACB0\uACFC \uC81C\uACF5

\uCD9C\uB825 \uD615\uC2DD: \uB9C8\uD06C\uB2E4\uC6B4
\uC5B8\uC5B4: ${request.language || "ko"}
${request.includeSourceReferences ? "\uAC01 \uC778\uC6A9\uC774\uB098 \uC815\uBCF4\uC5D0 \uCD9C\uCC98\uB97C \uBA85\uC2DC\uD574\uC8FC\uC138\uC694." : ""}`;
      const userPrompt = `${fullPrompt}

=== \uBD84\uC11D\uD560 \uC18C\uC2A4\uB4E4 (${request.sources.length}\uAC1C) ===

${sourcesContext}

=== \uBD84\uC11D \uC694\uCCAD ===
\uC704\uC758 ${request.sources.length}\uAC1C \uC18C\uC2A4\uB97C \uC885\uD569\uC801\uC73C\uB85C \uBD84\uC11D\uD574\uC8FC\uC138\uC694.`;
      const result = await this.callMultiSourceAI(provider, apiKey, systemPrompt, userPrompt);
      loading.hide();
      const sourceRefs = request.sources.map((s) => {
        if (s.metadata.url) {
          return `- [${s.title}](${s.metadata.url})`;
        } else if (s.metadata.filePath) {
          return `- [[${s.metadata.filePath}|${s.title}]]`;
        }
        return `- ${s.title}`;
      }).join("\n");
      const analysisTypeNames = {
        "synthesis": "\uC885\uD569 \uBD84\uC11D",
        "comparison": "\uBE44\uAD50 \uBD84\uC11D",
        "summary": "\uC694\uC57D",
        "custom": "\uCEE4\uC2A4\uD140 \uBD84\uC11D"
      };
      const noteContent = `---
type: multi-source-analysis
analysis-type: ${request.analysisType}
sources-count: ${request.sources.length}
total-chars: ${request.sources.reduce((acc, s) => acc + s.metadata.charCount, 0)}
provider: ${provider}
created: ${new Date().toISOString()}
---

# \uBA40\uD2F0 \uC18C\uC2A4 ${analysisTypeNames[request.analysisType]}

## \uBD84\uC11D \uAC1C\uC694
- **\uBD84\uC11D \uC720\uD615**: ${analysisTypeNames[request.analysisType]}
- **\uC18C\uC2A4 \uC218**: ${request.sources.length}\uAC1C
- **\uCD1D \uBD84\uC11D \uBB38\uC790 \uC218**: ${request.sources.reduce((acc, s) => acc + s.metadata.charCount, 0).toLocaleString()}\uC790
- **AI \uBAA8\uB378**: ${provider}
- **\uBD84\uC11D \uC77C\uC2DC**: ${new Date().toLocaleString("ko-KR")}

## \uBD84\uC11D \uACB0\uACFC

${result}

## \uBD84\uC11D\uC5D0 \uC0AC\uC6A9\uB41C \uC18C\uC2A4

${sourceRefs}

---
*\uC774 \uBD84\uC11D\uC740 Easy Gate \uBA40\uD2F0 \uC18C\uC2A4 \uBD84\uC11D \uAE30\uB2A5\uC73C\uB85C \uC0DD\uC131\uB418\uC5C8\uC2B5\uB2C8\uB2E4.*
`;
      const title = `\uBA40\uD2F0\uC18C\uC2A4_${analysisTypeNames[request.analysisType]}_${new Date().toISOString().split("T")[0]}`;
      await this.saveAnalysisResult(noteContent, title);
    } catch (error) {
      loading.hide();
      const errorMessage = error instanceof Error ? error.message : "\uBD84\uC11D \uC2E4\uD328";
      showError(`\uBA40\uD2F0 \uC18C\uC2A4 \uBD84\uC11D \uC624\uB958: ${errorMessage}`);
    }
  }
  async callMultiSourceAI(provider, apiKey, systemPrompt, userPrompt) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    const endpoints = {
      "gemini": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
      "grok": "https://api.x.ai/v1/chat/completions",
      "claude": "https://api.anthropic.com/v1/messages",
      "openai": "https://api.openai.com/v1/chat/completions",
      "glm": "https://open.bigmodel.cn/api/paas/v4/chat/completions"
    };
    const endpoint = endpoints[provider];
    if (!endpoint) {
      throw new Error(`\uC9C0\uC6D0\uD558\uC9C0 \uC54A\uB294 AI \uC81C\uACF5\uC790: ${provider}`);
    }
    const temperature = 0.7;
    const maxTokens = 8192;
    let response;
    let result;
    switch (provider) {
      case "gemini":
        response = await fetch(`${endpoint}?key=${apiKey}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ parts: [{ text: `${systemPrompt}

${userPrompt}` }] }],
            generationConfig: {
              temperature,
              maxOutputTokens: maxTokens
            }
          })
        });
        const geminiData = await response.json();
        result = ((_e = (_d = (_c = (_b = (_a = geminiData.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) || "";
        break;
      case "grok":
      case "openai":
        response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: provider === "grok" ? "grok-3-latest" : "gpt-4o-mini",
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt }
            ],
            temperature,
            max_tokens: maxTokens
          })
        });
        const openaiData = await response.json();
        result = ((_h = (_g = (_f = openaiData.choices) == null ? void 0 : _f[0]) == null ? void 0 : _g.message) == null ? void 0 : _h.content) || "";
        break;
      case "claude":
        response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-api-key": apiKey,
            "anthropic-version": "2023-06-01",
            "anthropic-dangerous-direct-browser-access": "true"
          },
          body: JSON.stringify({
            model: "claude-sonnet-4-20250514",
            max_tokens: maxTokens,
            system: systemPrompt,
            messages: [{ role: "user", content: userPrompt }]
          })
        });
        const claudeData = await response.json();
        result = ((_j = (_i = claudeData.content) == null ? void 0 : _i[0]) == null ? void 0 : _j.text) || "";
        break;
      case "glm":
        response = await fetch(endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "glm-4-flash",
            messages: [
              { role: "system", content: systemPrompt },
              { role: "user", content: userPrompt }
            ],
            temperature,
            max_tokens: maxTokens
          })
        });
        const glmData = await response.json();
        result = ((_m = (_l = (_k = glmData.choices) == null ? void 0 : _k[0]) == null ? void 0 : _l.message) == null ? void 0 : _m.content) || "";
        break;
      default:
        throw new Error(`\uC9C0\uC6D0\uD558\uC9C0 \uC54A\uB294 AI \uC81C\uACF5\uC790: ${provider}`);
    }
    if (!result) {
      throw new Error("AI \uC751\uB2F5\uC744 \uBC1B\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4.");
    }
    return result;
  }
  async savePromptToSettings(prompt2) {
    if (!this.plugin.settings.savedPrompts) {
      this.plugin.settings.savedPrompts = [];
    }
    this.plugin.settings.savedPrompts.push(prompt2);
    await this.plugin.saveSettings();
    if (this.aiDropdown) {
      this.aiDropdown.updateSettings(this.plugin.settings.ai, this.plugin.settings.savedPrompts);
    }
  }
  openAISettings() {
    var _a, _b, _c;
    (_a = this.app.setting) == null ? void 0 : _a.open();
    (_c = (_b = this.app.setting) == null ? void 0 : _b.openTabById) == null ? void 0 : _c.call(_b, this.plugin.manifest.id);
  }
  drawTopBar() {
    var _a;
    this.topBarEl = this.contentEl.createDiv({ cls: "gate-top-bar" });
    const tabBar = this.topBarEl.createDiv({ cls: "gate-tab-bar" });
    this.renderTabBar(tabBar);
    const controlRow = this.topBarEl.createDiv({ cls: "gate-control-row" });
    new import_obsidian14.ButtonComponent(controlRow).setIcon("arrow-left").setTooltip("Back").onClick(() => {
      if (!this.useIframe && this.frame.canGoBack()) {
        this.frame.goBack();
      }
    });
    new import_obsidian14.ButtonComponent(controlRow).setIcon("arrow-right").setTooltip("Forward").onClick(() => {
      if (!this.useIframe && this.frame.canGoForward()) {
        this.frame.goForward();
      }
    });
    const addressInput = new import_obsidian14.TextComponent(controlRow);
    addressInput.setPlaceholder("https://...");
    addressInput.inputEl.addClass("gate-address-input");
    addressInput.setValue(this.options.url);
    addressInput.inputEl.addEventListener("keydown", async (e) => {
      if (e.key === "Enter") {
        const url = addressInput.getValue();
        if (url) {
          await this.handleAddressEnter(url);
        }
      }
    });
    this.onFrameReady(() => {
      if (!this.useIframe) {
        this.frame.addEventListener("did-navigate", (e) => {
          addressInput.setValue(e.url);
        });
        this.frame.addEventListener("did-navigate-in-page", (e) => {
          addressInput.setValue(e.url);
        });
      }
    });
    controlRow.createSpan({ cls: "gate-divider" });
    const drop = new import_obsidian14.DropdownComponent(controlRow);
    drop.addOption("cursor", "Insert to: Cursor");
    drop.addOption("bottom", "Insert to: Bottom");
    drop.addOption("new", "Insert to: New Note");
    drop.setValue("cursor");
    drop.onChange((val) => this.insertMode = val);
    new import_obsidian14.ButtonComponent(controlRow).setIcon("download").setTooltip("Apply Selection").setButtonText("Apply").onClick(() => this.onApplyText());
    if (!this.useIframe) {
      controlRow.createSpan({ cls: "gate-divider" });
      if (this.clipDropdown) {
        createClipButton(controlRow, this.clipDropdown, () => this.handleClipPage());
      }
      if (this.aiDropdown) {
        const aiService = getAIService();
        const hasApiKey = (_a = aiService == null ? void 0 : aiService.isProviderConfigured(this.plugin.settings.ai.provider)) != null ? _a : false;
        createAIButton(controlRow, this.aiDropdown, () => this.openAnalysisModal(), hasApiKey);
      }
    }
  }
  renderTabBar(container) {
    container.empty();
    const gates = this.plugin.settings.gates;
    for (const id in gates) {
      const gate = gates[id];
      const tab = container.createDiv({ cls: "gate-tab" });
      if (gate.id === this.currentGateState.id)
        tab.addClass("active");
      const iconContainer = tab.createSpan({ cls: "gate-tab-icon" });
      (0, import_obsidian14.setIcon)(iconContainer, gate.icon || "globe");
      tab.createSpan({ text: gate.title, cls: "gate-tab-title" });
      const closeBtn = tab.createSpan({ cls: "gate-tab-close" });
      (0, import_obsidian14.setIcon)(closeBtn, "x");
      closeBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        const confirmDelete = confirm(`"${gate.title}" \uAC8C\uC774\uD2B8\uB97C \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?`);
        if (confirmDelete) {
          await this.plugin.removeGate(gate.id);
          this.renderTabBar(container);
          new import_obsidian14.Notice(`"${gate.title}" \uAC8C\uC774\uD2B8\uAC00 \uC0AD\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
        }
      });
      tab.addEventListener("click", () => {
        this.navigateTo(gate.url);
        this.currentGateState.url = gate.url;
        this.currentGateState.id = gate.id;
        this.currentGateState.title = gate.title;
        this.renderTabBar(container);
      });
    }
  }
  async handleAddressEnter(url) {
    if (!url.startsWith("http")) {
      url = "https://" + url;
    }
    const existing = this.plugin.findGateBy("url", url);
    if (existing) {
      this.navigateTo(existing.url);
      new import_obsidian14.Notice(`Switched to ${existing.title}`);
    } else {
      const domain = new URL(url).hostname;
      const newGate = normalizeGateOption({
        id: Math.random().toString(36).substring(2, 15),
        title: domain,
        url,
        icon: "globe"
      });
      newGate.id = Math.random().toString(36).substring(2, 10);
      await this.plugin.addGate(newGate);
      new import_obsidian14.Notice(`New Gate Created: ${domain}`);
      const bar = this.topBarEl.querySelector(".gate-tab-bar");
      if (bar)
        this.renderTabBar(bar);
      this.navigateTo(url);
    }
  }
  navigateTo(url) {
    if (this.frame instanceof HTMLIFrameElement) {
      this.frame.src = url;
    } else {
      this.frame.loadURL(url);
    }
  }
  async onApplyText() {
    let text = "";
    if (this.frame instanceof HTMLIFrameElement) {
      new import_obsidian14.Notice("Cannot extract text from IFrame mode (Mobile/Restricted).");
      return;
    } else {
      try {
        text = await this.frame.executeJavaScript("window.getSelection().toString()");
      } catch (e) {
        console.error(e);
      }
    }
    if (!text || text.trim() === "") {
      new import_obsidian14.Notice("No text selected in the browser.");
      return;
    }
    const formattedText = this.formatTextAsMarkdown(text);
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
    if (this.insertMode === "new") {
      try {
        const currentUrl = await ContentExtractor.getCurrentUrl(this.frame);
        const pageContent = await ContentExtractor.extractPageContent(this.frame);
        const pageTitle = (pageContent == null ? void 0 : pageContent.title) || this.currentGateState.title || "Web Clip";
        const siteName = (pageContent == null ? void 0 : pageContent.siteName) || this.extractSiteName(currentUrl);
        const now = new Date();
        const dateStr = now.toISOString().split("T")[0];
        const timeStr = now.toLocaleTimeString("ko-KR", { hour: "2-digit", minute: "2-digit" });
        const fullDateTime = `${dateStr} ${timeStr}`;
        const sanitizedTitle = pageTitle.replace(/[\\/:*?"<>|]/g, "-").substring(0, 50);
        let fileName = `${sanitizedTitle} - ${dateStr}.md`;
        fileName = await this.getUniqueFileName(fileName);
        const yamlFrontmatter = `---
title: "${pageTitle.replace(/"/g, '\\"')}"
source: "${currentUrl}"
site: "${siteName}"
clipped: ${fullDateTime}
type: web-clip
tags:
  - web-clip
  - easy-gate
---

`;
        const noteContent = `${yamlFrontmatter}# ${pageTitle}

> \u{1F517} **Source:** [${siteName}](${currentUrl})
> \u{1F4C5} **Clipped:** ${fullDateTime}

---

${formattedText}
`;
        const file = await this.plugin.app.vault.create(fileName, noteContent);
        await this.plugin.app.workspace.getLeaf("tab").openFile(file);
        new import_obsidian14.Notice(`Created new note: ${fileName}`);
      } catch (error) {
        console.error("Error creating note with metadata:", error);
        const baseFileName = `Note ${new Date().toISOString().slice(0, 19).replace(/T|:/g, "-")}.md`;
        const fileName = await this.getUniqueFileName(baseFileName);
        const file = await this.plugin.app.vault.create(fileName, formattedText);
        await this.plugin.app.workspace.getLeaf("tab").openFile(file);
        new import_obsidian14.Notice("Created new note with text.");
      }
      return;
    }
    if (!activeView) {
      new import_obsidian14.Notice("No active Markdown note found to insert text.");
      return;
    }
    const editor = activeView.editor;
    if (this.insertMode === "cursor") {
      editor.replaceSelection(formattedText);
    } else if (this.insertMode === "bottom") {
      const lastLine = editor.lineCount();
      editor.replaceRange("\n\n" + formattedText, { line: lastLine, ch: 0 });
    }
    new import_obsidian14.Notice("Text applied!");
  }
  formatTextAsMarkdown(text) {
    let formatted = text.trim();
    const lines = formatted.split("\n");
    const processedLines = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) {
        if (processedLines.length > 0 && processedLines[processedLines.length - 1] !== "") {
          processedLines.push("");
        }
        continue;
      }
      const numberedMatch = line.match(/^(\d+)[.)]\s*(.+)$/);
      if (numberedMatch) {
        processedLines.push(`${numberedMatch[1]}. ${numberedMatch[2]}`);
        continue;
      }
      const bulletMatch = line.match(/^[-*•▪▸►◦]\s*(.+)$/);
      if (bulletMatch) {
        processedLines.push(`- ${bulletMatch[1]}`);
        continue;
      }
      processedLines.push(line);
    }
    return processedLines.join("\n").replace(/\n{3,}/g, "\n\n");
  }
  async getUniqueFileName(fileName) {
    const baseName = fileName.replace(/\.md$/, "");
    const extension = ".md";
    if (!this.plugin.app.vault.getAbstractFileByPath(fileName)) {
      return fileName;
    }
    let counter = 1;
    let newFileName = `${baseName} (${counter})${extension}`;
    while (this.plugin.app.vault.getAbstractFileByPath(newFileName)) {
      counter++;
      newFileName = `${baseName} (${counter})${extension}`;
      if (counter > 100) {
        const timestamp2 = Date.now();
        newFileName = `${baseName} - ${timestamp2}${extension}`;
        break;
      }
    }
    return newFileName;
  }
  createFrame() {
    const onReady = () => {
      if (!this.isFrameReady) {
        this.isFrameReady = true;
        this.frameReadyCallbacks.forEach((callback) => callback());
      }
    };
    if (this.useIframe) {
      this.frame = createIframe(this.options, onReady);
    } else {
      this.frame = createWebviewTag(this.options, onReady, this.frameDoc);
      this.frame.addEventListener("new-window", (e) => {
        const url = e.url;
        if (!url)
          return;
        const oauthDomains = [
          "accounts.google.com",
          "accounts.youtube.com",
          "appleid.apple.com",
          "login.microsoftonline.com",
          "login.live.com",
          "github.com/login",
          "api.twitter.com",
          "facebook.com/dialog",
          "facebook.com/v"
        ];
        const isOAuthUrl = oauthDomains.some((domain) => url.includes(domain));
        if (isOAuthUrl) {
          this.navigateTo(url);
          return;
        }
        new GatePopupModal(this.plugin.app, url, this.options.profileKey).open();
      });
      this.frame.addEventListener("destroyed", () => {
        if (this.frameDoc != this.contentEl.doc) {
          if (this.frame) {
            this.frame.remove();
          }
          this.frameDoc = this.contentEl.doc;
          this.createFrame();
        }
      });
    }
    this.contentEl.appendChild(this.frame);
  }
  onunload() {
    if (this.frame) {
      this.frame.remove();
    }
    super.onunload();
  }
  onPaneMenu(menu, source) {
    super.onPaneMenu(menu, source);
    menu.addItem((item) => {
      item.setTitle("Reload");
      item.setIcon("refresh-ccw");
      item.onClick(() => {
        var _a;
        if (this.frame instanceof HTMLIFrameElement) {
          (_a = this.frame.contentWindow) == null ? void 0 : _a.location.reload();
        } else {
          this.frame.reload();
        }
      });
    });
  }
  getViewType() {
    var _a, _b;
    return (_b = (_a = this.options) == null ? void 0 : _a.id) != null ? _b : "gate";
  }
  getDisplayText() {
    var _a, _b;
    return (_b = (_a = this.options) == null ? void 0 : _a.title) != null ? _b : "Gate";
  }
  getIcon() {
    var _a, _b;
    return (_b = (_a = this.options) == null ? void 0 : _a.icon) != null ? _b : "globe";
  }
  onFrameReady(callback) {
    if (this.isFrameReady) {
      callback();
    } else {
      this.frameReadyCallbacks.push(callback);
    }
  }
  async setUrl(url) {
    this.navigateTo(url);
  }
};

// src/fns/openView.ts
var openView = async (workspace, id, position) => {
  let leafs = workspace.getLeavesOfType(id);
  if (leafs.length > 0) {
    workspace.revealLeaf(leafs[0]);
    return leafs[0];
  }
  const leaf = await createView(workspace, id, position);
  if (!leaf) {
    throw new Error(`Failed to create view with id: ${id}`);
  }
  workspace.revealLeaf(leaf);
  return leaf;
};
var createView = async (workspace, id, position) => {
  let leaf = null;
  switch (position) {
    case "left":
      leaf = workspace.getLeftLeaf(false);
      break;
    case "center":
      leaf = workspace.getLeaf(true);
      break;
    case "right":
    default:
      leaf = workspace.getRightLeaf(false);
      break;
  }
  if (leaf) {
    await leaf.setViewState({ type: id, active: true });
    return leaf;
  }
  return void 0;
};

// src/fns/registerGate.ts
var import_obsidian16 = require("obsidian");
var registerGate = (plugin, options) => {
  plugin.registerView(options.id, (leaf) => {
    return new GateView(leaf, options, plugin);
  });
  let iconName = options.icon;
  if (options.icon.startsWith("<svg")) {
    (0, import_obsidian16.addIcon)(options.id, options.icon);
    iconName = options.id;
  }
  if (options.hasRibbon) {
    plugin.addRibbonIcon(iconName, options.title, async (evt) => openView(plugin.app.workspace, options.id, options.position));
  }
  plugin.addCommand({
    id: `open-gate-${btoa(encodeURIComponent(options.url))}`,
    name: `Easy Gate: ${options.title}`,
    callback: async () => await openView(plugin.app.workspace, options.id, options.position)
  });
};

// src/ModalOnboarding.ts
var import_obsidian17 = require("obsidian");
var ModalOnBoarding = class extends import_obsidian17.Modal {
  constructor(app, gateOptions, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.gateOptions = gateOptions;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h3", { text: "Welcome to Easy Gate" });
    contentEl.createEl("p", {
      text: "Easy Gate is a plugin that allows you to embed any website in Obsidian. You will never have to leave Obsidian again!"
    });
    contentEl.createEl("p", {
      text: "If you need help, please visit our YouTube channel for tutorials."
    });
    contentEl.createEl("a", {
      cls: "community-link",
      text: "YouTube",
      attr: { href: "https://www.youtube.com/@%EB%B0%B0%EC%9B%80%EC%9D%98%EB%8B%AC%EC%9D%B8-p5v" }
    });
    contentEl.createEl("p", {
      text: "But now you have to create your first gate."
    });
    createFormEditGate(contentEl, this.gateOptions, (result) => {
      this.onSubmit(result);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/fns/unloadView.ts
var unloadView = async (workspace, gate) => {
  workspace.detachLeavesOfType(gate.id);
  const ribbonIcons = workspace.containerEl.querySelector(`div[aria-label="${gate.title}"]`);
  if (ribbonIcons) {
    ribbonIcons.remove();
  }
};

// src/ModalListGates.ts
var import_obsidian18 = require("obsidian");
var ModalListGates = class extends import_obsidian18.Modal {
  constructor(app, gates, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.gates = gates;
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    for (const gateId in this.gates) {
      const gate = this.gates[gateId];
      const container = contentEl.createEl("div", {
        cls: "open-gate--quick-list-item"
      });
      if (!gate.icon.startsWith("<svg")) {
        const iconSvg = (_a = (0, import_obsidian18.getIcon)(gate.icon)) != null ? _a : (0, import_obsidian18.getIcon)("link-external");
        iconSvg.classList.add("svg-icon");
        container.appendChild(iconSvg);
      } else {
        container.createEl("svg", { cls: "svg-icon" }).innerHTML = gate.icon;
      }
      container.createEl("span", { text: gate.title });
      container.addEventListener("click", async () => {
        await openView(this.app.workspace, gate.id, gate.position);
        this.close();
      });
    }
  }
};

// src/fns/registerCodeBlockProcessor.ts
var import_obsidian19 = require("obsidian");

// node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a;
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = (_a = match.find((t) => !t.format)) != null ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => {
    var _a2;
    return ((_a2 = t.identify) == null ? void 0 : _a2.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b, _c;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_c = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _c.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch (e) {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t) => t.format === item.format)) != null ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags.filter((t) => {
      var _a2;
      return (_a2 = t.identify) == null ? void 0 : _a2.call(t, obj);
    });
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = (_b = match.find((t) => t.format === item.format)) != null ? _b : match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  var _a, _b;
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = (_b = (_a = ctx.inFlow) != null ? _a : value.flow) != null ? _b : value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
var MERGE_KEY = "<<";
var merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && (ctx == null ? void 0 : ctx.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default));
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) != null ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar(node) ? node.value : node) != null ? _a : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) != null ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  setIn(path, value) {
    if (isEmptyPath(path)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || (next == null ? void 0 : next.type) !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow != null ? flow : "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || (next == null ? void 0 : next.type) === "block-map" || (next == null ? void 0 : next.type) === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start != null ? start : end
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  var _a, _b;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_b = keyProps.found) == null ? void 0 : _b.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep != null ? sep : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd != null ? commentEnd : offset];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  var _a;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd != null ? commentEnd : offset];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  var _a, _b;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : isMap2 ? YAMLMap : YAMLSeq;
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_b = prev.value) != null ? _b : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep != null ? sep : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode != null ? valueNode : keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  var _a, _b;
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor != null ? anchor : tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt == null ? void 0 : kt.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = (_b = (_a = tag.resolve) == null ? void 0 : _a.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) != null ? _b : coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (e) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + ((_a = match == null ? void 0 : match[1]) != null ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  var _a;
  const tag = schema4.tags.find((tag2) => {
    var _a2;
    return (tag2.default === true || atKey && tag2.default === "key") && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a = schema4.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
    })) != null ? _a : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag != null ? tag : token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value != null ? value : end == null ? void 0 : end[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) == null ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) != null ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i2;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i2 + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error != null ? error : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atMapIndent && bv.type !== "block-seq") {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}

// src/fns/registerCodeBlockProcessor.ts
function processNewSyntax(plugin, sourceCode) {
  const firstLineUrl = sourceCode.split("\n")[0];
  if (firstLineUrl.startsWith("http")) {
    sourceCode = sourceCode.replace(firstLineUrl, "").trim();
  }
  sourceCode = sourceCode.replace(/^\t+/gm, (match) => "  ".repeat(match.length));
  if (sourceCode.length === 0) {
    return createFrame(createEmptyGateOption(), "800px");
  }
  let data = {};
  if (firstLineUrl.startsWith("http")) {
    data.url = firstLineUrl;
  }
  try {
    data = Object.assign(data, parse(sourceCode));
  } catch (error) {
    return createErrorMessage(error);
  }
  if (typeof data !== "object" || data === null || Object.keys(data).length === 0) {
    return createErrorMessage();
  }
  let height = "800px";
  if (data.height) {
    height = typeof data.height === "number" ? `${data.height}px` : data.height;
    delete data.height;
  }
  let prefill;
  if (data.title) {
    prefill = plugin.findGateBy("title", data.title);
  } else if (data.url) {
    prefill = plugin.findGateBy("url", data.url);
  }
  if (prefill) {
    data = Object.assign(prefill, data);
  }
  return createFrame(normalizeGateOption(data), height);
}
function createErrorMessage(error) {
  const div = document.createElement("div");
  const messageText = "The syntax has been updated. Please use the YAML format.";
  const messageTextNode = document.createTextNode(messageText);
  div.appendChild(messageTextNode);
  if (error) {
    const errorDetailsText = `
Error details: ${error.message}`;
    const errorDetailsTextNode = document.createTextNode(errorDetailsText);
    div.appendChild(errorDetailsTextNode);
  }
  const linkText = "\nRead more about YAML here.";
  const linkTextNode = document.createTextNode(linkText);
  const linkNode = document.createElement("a");
  linkNode.href = "https://yaml.org/spec/1.2/spec.html";
  linkNode.textContent = "YAML Syntax";
  div.appendChild(linkTextNode);
  div.appendChild(linkNode);
  return div;
}
function createFrame(options, height) {
  let frame;
  if (import_obsidian19.Platform.isMobileApp) {
    frame = createIframe(options);
  } else {
    frame = createWebviewTag(options);
  }
  frame.style.height = height;
  return frame;
}
function registerCodeBlockProcessor(plugin) {
  plugin.registerMarkdownCodeBlockProcessor("gate", (sourceCode, el, _ctx) => {
    el.addClass("open-gate-view");
    const frame = processNewSyntax(plugin, sourceCode);
    el.appendChild(frame);
  });
}

// src/fns/setupLinkConvertMenu.ts
var import_obsidian20 = require("obsidian");
var setupLinkConvertMenu = (plugin) => {
  plugin.registerEvent(plugin.app.workspace.on("editor-menu", createMenu));
};
var parseLink = (text) => {
  const markdownLinkMatch = text.match(/\[([^\]]+)\]\(([^)]+)\)/);
  if (markdownLinkMatch) {
    return {
      title: markdownLinkMatch[1],
      url: markdownLinkMatch[2]
    };
  }
  const urlMatch = text.match(/https?:\/\/[^ ]+/);
  if (urlMatch) {
    return {
      title: urlMatch[0],
      url: urlMatch[0]
    };
  }
};
var createMenu = (menu, editor) => {
  const selection = editor.getSelection();
  if (selection.length === 0)
    return;
  const parsedLink = parseLink(selection);
  if (!parsedLink)
    return;
  if (parsedLink.url.startsWith("obsidian://opengate")) {
    menu.addItem((item) => {
      item.setTitle("Convert to normal link").onClick(async () => {
        const urlMatch = parsedLink.url.match(/url=([^&]+)/);
        if (!urlMatch) {
          new import_obsidian20.Notice("Can not convert the pre-configured gate link to normal link.");
          return;
        }
        const url = decodeURIComponent(urlMatch[1]);
        const normalLink = `[${parsedLink.title}](${url})`;
        editor.replaceSelection(normalLink);
      });
    });
  } else {
    menu.addItem((item) => {
      item.setTitle("Convert to Gate Link").onClick(async () => {
        const gateLink = `[${parsedLink.title}](obsidian://opengate?title=${encodeURIComponent(parsedLink.title)}&url=${encodeURIComponent(parsedLink.url)})`;
        editor.replaceSelection(gateLink);
      });
    });
  }
};

// src/ModalInsertLink.ts
var import_obsidian21 = require("obsidian");
var ModalInsertLink = class extends import_obsidian21.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    this.titleEl.setText("Insert Link");
    this.createFormInsertLink();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createFormInsertLink() {
    let gateOptions = createEmptyGateOption();
    new import_obsidian21.Setting(this.contentEl).setName("URL").setClass("open-gate--form-field").addText((text) => text.setPlaceholder("https://example.com").onChange(async (value) => {
      gateOptions.url = value;
    }));
    new import_obsidian21.Setting(this.contentEl).setName("Title").setClass("open-gate--form-field").addText((text) => text.onChange(async (value) => {
      gateOptions.title = value;
    }));
    new import_obsidian21.Setting(this.contentEl).addButton((btn) => btn.setButtonText("Insert Link").setCta().onClick(async () => {
      gateOptions = normalizeGateOption(gateOptions);
      this.onSubmit(gateOptions);
    }));
  }
};

// src/fns/setupInsertLinkMenu.ts
var setupInsertLinkMenu = (plugin) => {
  plugin.registerEvent(plugin.app.workspace.on("editor-menu", (menu, editor) => createMenu2(plugin.app, menu, editor)));
};
var createMenu2 = (app, menu, editor) => {
  menu.addItem((item) => {
    item.setTitle("Insert Gate Link").onClick(async () => {
      const modal = new ModalInsertLink(app, async (gate) => {
        const gateLink = `[${gate.title}](obsidian://opengate?title=${encodeURIComponent(gate.title)}&url=${encodeURIComponent(gate.url)})`;
        editor.replaceSelection(gateLink);
        modal.close();
      });
      modal.open();
    });
  });
};

// src/main.ts
init_types();
var DEFAULT_SETTINGS = {
  uuid: "",
  gates: {},
  ai: DEFAULT_AI_SETTINGS,
  clipping: DEFAULT_CLIPPING_SETTINGS,
  savedPrompts: []
};
var OpenGatePlugin = class extends import_obsidian22.Plugin {
  async onload() {
    await this.loadSettings();
    await this.mayShowOnboardingDialog();
    await this.initGates();
    this.addSettingTab(new SettingTab(this.app, this));
    this.registerCommands();
    this.registerProtocol();
    setupLinkConvertMenu(this);
    setupInsertLinkMenu(this);
    registerCodeBlockProcessor(this);
  }
  async mayShowOnboardingDialog() {
    if (this.settings.uuid === "") {
      this.settings.uuid = this.generateUuid();
      await this.saveSettings();
      if (Object.keys(this.settings.gates).length === 0) {
        new ModalOnBoarding(this.app, createEmptyGateOption(), async (gate) => {
          await this.addGate(gate);
        }).open();
      }
    }
  }
  async initGates() {
    for (const gateId in this.settings.gates) {
      const gate = this.settings.gates[gateId];
      registerGate(this, gate);
    }
    registerGate(this, normalizeGateOption({
      id: "temp-gate",
      title: "Temp Gate",
      icon: "globe",
      url: "about:blank"
    }));
  }
  registerCommands() {
    this.addCommand({
      id: `open-gate-create-new`,
      name: `Easy Gate: Create new`,
      callback: async () => {
        new ModalEditGate(this.app, createEmptyGateOption(), async (gate) => {
          await this.addGate(gate);
        }).open();
      }
    });
    this.addCommand({
      id: `open-list-gates-modal`,
      name: `Easy Gate: List all`,
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "g" }],
      callback: async () => {
        new ModalListGates(this.app, this.settings.gates, async (gate) => {
          await this.addGate(gate);
        }).open();
      }
    });
  }
  registerProtocol() {
    this.registerObsidianProtocolHandler("opengate", this.handleCustomProtocol.bind(this));
  }
  getGateOptionFromProtocolData(data) {
    const { title, url, id, position } = data;
    let targetGate;
    if (id && this.settings.gates[id]) {
      targetGate = this.settings.gates[id];
    } else {
      targetGate = Object.values(this.settings.gates).find((gate) => title && gate.title.toLowerCase() === title.toLowerCase() || url && gate.url.toLowerCase() === url.toLowerCase());
    }
    if (!targetGate) {
      targetGate = createEmptyGateOption();
    }
    if (url) {
      targetGate.url = url;
    }
    if (position) {
      targetGate.position = position;
    }
    return targetGate;
  }
  findGateBy(field, value) {
    return Object.values(this.settings.gates).find((gate) => gate[field].toLowerCase() === value.toLowerCase());
  }
  async handleCustomProtocol(data) {
    let targetGate = this.getGateOptionFromProtocolData(data);
    if (targetGate === void 0) {
      if (!data.url) {
        new import_obsidian22.Notice("Missing url parameter");
        return;
      }
    }
    const gate = await openView(this.app.workspace, (targetGate == null ? void 0 : targetGate.id) || "temp-gate", targetGate == null ? void 0 : targetGate.position);
    const gateView = gate.view;
    gateView == null ? void 0 : gateView.onFrameReady(() => {
      gateView.setUrl(data.url);
    });
  }
  async addGate(gate) {
    const normalizedGate = normalizeGateOption(gate);
    if (!this.settings.gates.hasOwnProperty(normalizedGate.id)) {
      registerGate(this, normalizedGate);
    } else {
      new import_obsidian22.Notice("This change will take effect after you reload Obsidian.");
    }
    this.settings.gates[normalizedGate.id] = normalizedGate;
    await this.saveSettings();
  }
  async removeGate(gateId) {
    if (!this.settings.gates[gateId]) {
      new import_obsidian22.Notice("Gate not found");
      return;
    }
    const gate = this.settings.gates[gateId];
    await unloadView(this.app.workspace, gate);
    delete this.settings.gates[gateId];
    await this.saveSettings();
    new import_obsidian22.Notice("This change will take effect after you reload Obsidian.");
  }
  async loadSettings() {
    var _a, _b;
    const loadedData = await this.loadData();
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...loadedData
    };
    if (!this.settings.gates) {
      this.settings.gates = {};
    }
    this.settings.ai = {
      ...DEFAULT_AI_SETTINGS,
      ...(loadedData == null ? void 0 : loadedData.ai) || {}
    };
    this.settings.ai.models = {
      ...DEFAULT_AI_SETTINGS.models,
      ...((_a = loadedData == null ? void 0 : loadedData.ai) == null ? void 0 : _a.models) || {}
    };
    this.settings.ai.apiKeys = {
      ...((_b = loadedData == null ? void 0 : loadedData.ai) == null ? void 0 : _b.apiKeys) || {}
    };
    this.settings.clipping = {
      ...DEFAULT_CLIPPING_SETTINGS,
      ...(loadedData == null ? void 0 : loadedData.clipping) || {}
    };
    if (!this.settings.savedPrompts) {
      this.settings.savedPrompts = [];
    }
    for (const gateId in this.settings.gates) {
      this.settings.gates[gateId] = normalizeGateOption(this.settings.gates[gateId]);
    }
    initializeAIService(this.settings.ai);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    updateAIServiceSettings(this.settings.ai);
  }
  generateUuid() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
};
